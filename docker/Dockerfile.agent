# Dockerfile для установки Cursor CLI (agent)
# Основан на Ubuntu для поддержки официального установщика
FROM ubuntu:22.04

# Установка необходимых зависимостей
RUN apt-get update && apt-get install -y \
    curl \
    bash \
    git \
    ca-certificates \
    util-linux \
    procps \
    openssh-client \
    # Установка build-essential и python3-pip для возможных зависимостей
    build-essential \
    python3-pip \
    # Добавляем sudo для удобства отладки, но в production рекомендуется без него
    sudo \
    && rm -rf /var/lib/apt/lists/*

# util-linux содержит утилиту 'script' для создания pseudo-TTY
# Необходима для обхода проблемы Ink в Cursor CLI (требует TTY)
# procps содержит утилиты для мониторинга процессов (pgrep, ps, free)

# Создание рабочей директории
WORKDIR /workspace

# Установка Cursor CLI (agent) через официальный скрипт
RUN curl https://cursor.com/install -fsS | bash

# Добавление ~/.local/bin в PATH
ENV PATH="${PATH}:/root/.local/bin"

# Проверка установки
RUN agent --version || echo "Agent installation check"

# Установка переменных окружения
ENV AGENT_WORKING_DIR=/workspace
ENV AGENT_HOME=/root

# Примечание: CURSOR_API_KEY должен быть передан через docker-compose.agent.yml
# или через переменные окружения при запуске контейнера

# Настройка SSH для GitHub (если SSH-ключи монтируются из хоста)
RUN mkdir -p /root/.ssh && \
    chmod 700 /root/.ssh && \
    touch /root/.ssh/config && \
    chmod 600 /root/.ssh/config && \
    echo "Host github.com" >> /root/.ssh/config && \
    echo "  StrictHostKeyChecking no" >> /root/.ssh/config && \
    echo "  UserKnownHostsFile=/dev/null" >> /root/.ssh/config

# --- Security Enhancements: Non-Root User --- Start
# Создание группы и пользователя с ограниченными правами
RUN groupadd -r appgroup && useradd -r -g appgroup -s /sbin/nologin -u 1000 appuser

# Настройка домашней директории для appuser и предоставление ему прав на запись в /workspace
RUN mkdir -p /home/appuser/.local/bin && \
    chown -R appuser:appgroup /home/appuser && \
    chown -R appuser:appgroup /workspace && \
    chmod -R 755 /workspace

# Переключение на пользователя с ограниченными правами
USER appuser

# Обновление PATH для appuser, чтобы включать ~/.local/bin
ENV PATH="/home/appuser/.local/bin:${PATH}"

# --- Security Enhancements: Non-Root User --- End

# Создание скрипта запуска с логированием
RUN cat > /start.sh << 'EOF'
#!/usr/bin/env bash
set -e

# Функция логирования
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

# Настройка SSH-ключей (исправление прав доступа при монтировании из Windows)
# При монтировании из Windows права теряются, поэтому копируем ключи в /root/.ssh-local
# Эта секция будет выполняться от имени appuser, поэтому корректируем пути.
if [ -d /root/.ssh ]; then
    log "SSH directory found: /root/.ssh (Note: this should ideally be mounted to appuser's home)"
    # Создаем локальную директорию для SSH с правильными правами для appuser
    mkdir -p /home/appuser/.ssh-local
    chmod 700 /home/appuser/.ssh-local
    
    # Копируем и настраиваем ключи
    # Примечание: Если SSH-ключи монтируются, они должны быть доступны для appuser
    # В production, рекомендуется монтировать ключи напрямую в /home/appuser/.ssh-local
    if [ -f /root/.ssh/id_ed25519 ]; then
        # Используем install для копирования с правильными правами сразу
        install -m 600 /root/.ssh/id_ed25519 /home/appuser/.ssh-local/id_ed25519
        [ -f /root/.ssh/id_ed25519.pub ] && install -m 644 /root/.ssh/id_ed25519.pub /home/appuser/.ssh-local/id_ed25519.pub || true
        # Копируем config если есть
        [ -f /root/.ssh/config ] && install -m 600 /root/.ssh/config /home/appuser/.ssh-local/config || true
        # Дополнительная проверка и установка прав (на случай если install не сработал)
        chmod 600 /home/appuser/.ssh-local/id_ed25519 2>/dev/null || true
        [ -f /home/appuser/.ssh-local/id_ed25519.pub ] && chmod 644 /home/appuser/.ssh-local/id_ed25519.pub 2>/dev/null || true
        # Проверяем, что права установлены правильно
        KEY_PERMS=$(stat -c "%a" /home/appuser/.ssh-local/id_ed25519 2>/dev/null || echo "unknown")
        log "SSH key configured in /home/appuser/.ssh-local (perms: $KEY_PERMS) - git push should work"
    elif [ -f /root/.ssh/id_rsa ]; then
        install -m 600 /root/.ssh/id_rsa /home/appuser/.ssh-local/id_rsa
        [ -f /root/.ssh/id_rsa.pub ] && install -m 644 /root/.ssh/id_rsa.pub /home/appuser/.ssh-local/id_rsa.pub || true
        [ -f /root/.ssh/config ] && install -m 600 /root/.ssh/config /home/appuser/.ssh-local/config || true
        chmod 600 /home/appuser/.ssh-local/id_rsa 2>/dev/null || true
        [ -f /home/appuser/.ssh-local/id_rsa.pub ] && chmod 644 /home/appuser/.ssh-local/id_rsa.pub 2>/dev/null || true
        KEY_PERMS=$(stat -c "%a" /home/appuser/.ssh-local/id_rsa 2>/dev/null || echo "unknown")
        log "SSH key configured in /home/appuser/.ssh-local (perms: $KEY_PERMS) - git push should work"
    else
        log "Warning: No SSH key found in /root/.ssh (expected to be mounted to appuser's home)"
    fi
    
    # Настраиваем SSH для использования локальной директории
    if [ -d /home/appuser/.ssh-local ] && ([ -f /home/appuser/.ssh-local/id_ed25519 ] || [ -f /home/appuser/.ssh-local/id_rsa ]); then
        # Устанавливаем GIT_SSH_COMMAND глобально для всех git команд
        if [ -f /home/appuser/.ssh-local/id_ed25519 ]; then
            SSH_CMD="ssh -i /home/appuser/.ssh-local/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=no"
        elif [ -f /home/appuser/.ssh-local/id_rsa ]; then
            SSH_CMD="ssh -i /home/appuser/.ssh-local/id_rsa -o IdentitiesOnly=yes -o StrictHostKeyChecking=no"
        fi
        
        if [ -n "$SSH_CMD" ]; then
            export GIT_SSH_COMMAND="$SSH_CMD"
            # Настраиваем git config глобально (более надежно, чем переменная окружения)
            git config --global core.sshCommand "$SSH_CMD"
            # Также добавляем в .bashrc для интерактивных сессий
            echo "export GIT_SSH_COMMAND=\"$SSH_CMD\"" >> /home/appuser/.bashrc
            # Добавляем в .profile для всех login shell
            echo "export GIT_SSH_COMMAND=\"$SSH_CMD\"" >> /home/appuser/.profile
            log "Git SSH configured globally: $SSH_CMD"
        fi
    fi
fi

log "=== Cursor Agent Container Started === (as appuser)"
log "Container ID: $(hostname)"
log "Container IP: $(hostname -i 2>/dev/null || echo 'N/A')"
log "Image: cursor-agent:latest"

# Основной цикл с периодическими сообщениями и мониторингом
while true; do
    # Вычисляем uptime
    if [ -f /proc/uptime ]; then
        UPTIME_SEC=$(awk '{print int($1)}' /proc/uptime)
        UPTIME_HOURS=$((UPTIME_SEC / 3600))
        UPTIME_MINS=$(((UPTIME_SEC % 3600) / 60))
        UPTIME_STR="${UPTIME_HOURS}h ${UPTIME_MINS}m"
    else
        UPTIME_STR="N/A"
    fi
    
    log "Status: Running | Uptime: ${UPTIME_STR}"
    
    # Проверка использования памяти
    if command -v free >/dev/null 2>&1; then
        MEM_INFO=$(free -h 2>/dev/null | awk '/^Mem:/ {print $3"/"$2}' || echo "N/A")
        log "Memory usage: ${MEM_INFO}"
    fi
    
    # Проверка установки Cursor Agent CLI (команда, а не процесс)
    # Теперь агент должен быть доступен через PATH appuser
    if command -v agent >/dev/null 2>&1; then
        AGENT_CMD=$(command -v agent 2>/dev/null)
        if [ -n "$AGENT_CMD" ]; then
            AGENT_VERSION=$($AGENT_CMD --version 2>/dev/null | head -1 || echo "unknown")
            log "Cursor Agent: Installed | Path: ${AGENT_CMD} | Version: ${AGENT_VERSION}"
        else
            log "Cursor Agent: Not found in PATH for appuser"
        fi
    else
        log "Cursor Agent: Not installed for appuser - attempting reinstall as root (not recommended in production)"
        # В данном сценарии, переустановка агента от имени appuser может быть проблематичной
        # так как она может требовать прав root. В production, агент должен быть установлен до переключения на appuser.
        # Здесь просто логируем, что агент не найден для appuser.
    fi
    
    sleep 3600
done
EOF

# Перед переключением на appuser, start.sh должен быть создан и иметь правильные права
# Скрипт start.sh должен быть доступен для выполнения appuser
RUN chmod +x /start.sh && \
    sed -i 's/\r$//' /start.sh && \
    ls -la /start.sh && \
    chown appuser:appgroup /start.sh # Передаем владение скриптом appuser

# HEALTHCHECK для мониторинга здоровья контейнера (выполняется от имени appuser)
HEALTHCHECK --interval=1m --timeout=3s --start-period=5s --retries=3 \
  CMD ps aux | grep -v grep | grep -q "start.sh" || exit 1

# Использовать скрипт как точку входа (переопределяется в docker-compose.agent.yml)
# Теперь CMD будет выполняться от имени appuser
CMD ["/start.sh"]

# --- Security Scanning & Vulnerability Assessment Notes ---
# Для полноценного security scanning и vulnerability assessment рекомендуется:
# 1. Использовать инструменты типа Trivy, Snyk, Clair в CI/CD пайплайне для сканирования образов.
# 2. Регулярно обновлять базовые образы и зависимости.
# 3. Использовать multi-stage builds для уменьшения финального размера образа и атаки.
# 4. Проводить статический анализ кода (SAST) и динамический анализ (DAST) для приложения.
# 5. Внедрить мониторинг безопасности в runtime. 