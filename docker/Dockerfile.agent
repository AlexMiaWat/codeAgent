# Dockerfile для установки Cursor CLI (agent)
# Основан на Ubuntu для поддержки официального установщика
FROM ubuntu:22.04

# Установка необходимых зависимостей
RUN apt-get update && apt-get install -y \
    curl \
    bash \
    git \
    ca-certificates \
    util-linux \
    procps \
    openssh-client \
    && rm -rf /var/lib/apt/lists/*

# util-linux содержит утилиту 'script' для создания pseudo-TTY
# Необходима для обхода проблемы Ink в Cursor CLI (требует TTY)
# procps содержит утилиты для мониторинга процессов (pgrep, ps, free)

# Создание рабочей директории
WORKDIR /workspace

# Установка Cursor CLI (agent) через официальный скрипт
RUN curl https://cursor.com/install -fsS | bash

# Добавление ~/.local/bin в PATH
ENV PATH="${PATH}:/root/.local/bin"

# Проверка установки
RUN agent --version || echo "Agent installation check"

# Установка переменных окружения
ENV AGENT_WORKING_DIR=/workspace
ENV AGENT_HOME=/root

# Примечание: CURSOR_API_KEY должен быть передан через docker-compose.agent.yml
# или через переменные окружения при запуске контейнера

# Настройка SSH для GitHub (если SSH-ключи монтируются из хоста)
RUN mkdir -p /root/.ssh && \
    chmod 700 /root/.ssh && \
    touch /root/.ssh/config && \
    chmod 600 /root/.ssh/config && \
    echo "Host github.com" >> /root/.ssh/config && \
    echo "  StrictHostKeyChecking no" >> /root/.ssh/config && \
    echo "  UserKnownHostsFile=/dev/null" >> /root/.ssh/config

# Создание скрипта запуска с логированием
RUN cat > /start.sh << 'EOF'
#!/usr/bin/env bash
set -e

# Функция логирования
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

# Настройка SSH-ключей (исправление прав доступа при монтировании из Windows)
# При монтировании из Windows права теряются, поэтому копируем ключи в /root/.ssh-local
if [ -d /root/.ssh ]; then
    log "SSH directory found: /root/.ssh"
    # Создаем локальную директорию для SSH с правильными правами
    mkdir -p /root/.ssh-local
    chmod 700 /root/.ssh-local
    
    # Копируем и настраиваем ключи
    if [ -f /root/.ssh/id_ed25519 ]; then
        cat /root/.ssh/id_ed25519 > /root/.ssh-local/id_ed25519
        cat /root/.ssh/id_ed25519.pub > /root/.ssh-local/id_ed25519.pub 2>/dev/null || true
        chmod 600 /root/.ssh-local/id_ed25519
        chmod 644 /root/.ssh-local/id_ed25519.pub 2>/dev/null || true
        # Копируем config если есть
        [ -f /root/.ssh/config ] && cat /root/.ssh/config > /root/.ssh-local/config && chmod 600 /root/.ssh-local/config || true
        # Используем локальную директорию
        export GIT_SSH_COMMAND="ssh -i /root/.ssh-local/id_ed25519 -o IdentitiesOnly=yes"
        log "SSH key configured in /root/.ssh-local - git push should work"
    elif [ -f /root/.ssh/id_rsa ]; then
        cat /root/.ssh/id_rsa > /root/.ssh-local/id_rsa
        cat /root/.ssh/id_rsa.pub > /root/.ssh-local/id_rsa.pub 2>/dev/null || true
        chmod 600 /root/.ssh-local/id_rsa
        chmod 644 /root/.ssh-local/id_rsa.pub 2>/dev/null || true
        [ -f /root/.ssh/config ] && cat /root/.ssh/config > /root/.ssh-local/config && chmod 600 /root/.ssh-local/config || true
        export GIT_SSH_COMMAND="ssh -i /root/.ssh-local/id_rsa -o IdentitiesOnly=yes"
        log "SSH key configured in /root/.ssh-local - git push should work"
    else
        log "Warning: No SSH key found in /root/.ssh"
    fi
    
    # Настраиваем SSH для использования локальной директории
    if [ -d /root/.ssh-local ]; then
        # Устанавливаем GIT_SSH_COMMAND глобально для всех git команд
        if [ -f /root/.ssh-local/id_ed25519 ]; then
            export GIT_SSH_COMMAND="ssh -i /root/.ssh-local/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=no"
            echo 'export GIT_SSH_COMMAND="ssh -i /root/.ssh-local/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=no"' >> /root/.bashrc
        elif [ -f /root/.ssh-local/id_rsa ]; then
            export GIT_SSH_COMMAND="ssh -i /root/.ssh-local/id_rsa -o IdentitiesOnly=yes -o StrictHostKeyChecking=no"
            echo 'export GIT_SSH_COMMAND="ssh -i /root/.ssh-local/id_rsa -o IdentitiesOnly=yes -o StrictHostKeyChecking=no"' >> /root/.bashrc
        fi
        # Также добавляем в /etc/environment для всех процессов
        [ -f /root/.ssh-local/id_ed25519 ] && echo 'GIT_SSH_COMMAND="ssh -i /root/.ssh-local/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=no"' >> /etc/environment || true
        [ -f /root/.ssh-local/id_rsa ] && echo 'GIT_SSH_COMMAND="ssh -i /root/.ssh-local/id_rsa -o IdentitiesOnly=yes -o StrictHostKeyChecking=no"' >> /etc/environment || true
    fi
fi

log "=== Cursor Agent Container Started ==="
log "Container ID: $(hostname)"
log "Container IP: $(hostname -i 2>/dev/null || echo 'N/A')"
log "Image: cursor-agent:latest"

# Основной цикл с периодическими сообщениями и мониторингом
while true; do
    # Вычисляем uptime
    if [ -f /proc/uptime ]; then
        UPTIME_SEC=$(awk '{print int($1)}' /proc/uptime)
        UPTIME_HOURS=$((UPTIME_SEC / 3600))
        UPTIME_MINS=$(((UPTIME_SEC % 3600) / 60))
        UPTIME_STR="${UPTIME_HOURS}h ${UPTIME_MINS}m"
    else
        UPTIME_STR="N/A"
    fi
    
    log "Status: Running | Uptime: ${UPTIME_STR}"
    
    # Проверка использования памяти
    if command -v free >/dev/null 2>&1; then
        MEM_INFO=$(free -h 2>/dev/null | awk '/^Mem:/ {print $3"/"$2}' || echo "N/A")
        log "Memory usage: ${MEM_INFO}"
    fi
    
    # Проверка cursor-agent процесса
    if command -v pgrep >/dev/null 2>&1; then
        if pgrep -f "cursor-agent\|agent" > /dev/null 2>&1; then
            AGENT_PID=$(pgrep -f "cursor-agent\|agent" | head -1)
            if [ -n "$AGENT_PID" ] && command -v ps >/dev/null 2>&1; then
                AGENT_MEM=$(ps -p "$AGENT_PID" -o rss= 2>/dev/null | awk '{print int($1/1024)"MB"}' || echo "N/A")
                log "Cursor Agent: Active | PID: ${AGENT_PID} | Memory: ${AGENT_MEM}"
            else
                log "Cursor Agent: Active | PID: ${AGENT_PID}"
            fi
        else
            log "Cursor Agent: Not detected"
        fi
    fi
    
    sleep 3600
done
EOF

RUN chmod +x /start.sh && \
    sed -i 's/\r$//' /start.sh && \
    ls -la /start.sh

# HEALTHCHECK для мониторинга здоровья контейнера
HEALTHCHECK --interval=1m --timeout=3s --start-period=5s --retries=3 \
  CMD ps aux | grep -v grep | grep -q "start.sh" || exit 1

# Использовать скрипт как точку входа (переопределяется в docker-compose.agent.yml)
CMD ["/start.sh"]
