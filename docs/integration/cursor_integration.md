# Интеграция Code Agent с Cursor

## Обзор взаимодействия

Code Agent работает как **координатор задач**, взаимодействуя с Cursor IDE через интерфейс пользователя. Агент не выполняет код напрямую, а делегирует выполнение задач агентам Cursor через систему диалогов.

## Важно: Мощные модели Cursor

⚠️ **Cursor IDE содержит очень умные языковые модели последнего поколения** (GPT-4, Claude Opus, GPT-4 Turbo и т.д.), которые:

- ✅ **Понимают контекст с полуслова** - не требуют детальных инструкций
- ✅ **Выполняют сложные задачи** - генерация кода, рефакторинг, архитектурное планирование
- ✅ **Подробно протоколируют работу** - создают детальные отчеты с полным контекстом
- ✅ **Анализируют документацию** - глубокий анализ проектной документации
- ✅ **Принимают сложные решения** - deep thinking для архитектурных решений

**Поэтому для Cursor не составляет труда:**
- Выполнять задачи от Code Agent по простым инструкциям
- Понимать контекст проекта без детального объяснения
- Создавать подробные отчеты о проделанной работе
- Протоколировать каждый шаг выполнения

**Ключевой момент:** Code Agent использует **слабые модели** для координации, а Cursor использует **мощные модели** для интеллектуальной работы. Это правильное разделение ответственности.

## Основные принципы взаимодействия

### Роли компонентов

- **Code Agent** (CrewAI, слабая LLM):
  - Читает задачи из `todo.txt`
  - Выбирает шаблоны инструкций из конфигурации (НЕ планирует)
  - Генерирует команды и инструкции для Cursor (используя шаблоны)
  - **Контролирует выполнение через файлы-репорты** - ключевой механизм взаимодействия
  - **Дожидается выполнения работы Cursor** - проверяет файлы-репорты
  - Ведет протокол в `codeAgentProjectStatus.md`

- **Cursor Agents** (мощные модели последнего поколения):
  - Используют **очень умные языковые модели** (GPT-4, Claude Opus, GPT-4 Turbo и т.д.)
  - **Понимают контекст с полуслова** - не требуют детальных инструкций
  - Получают инструкции от Code Agent
  - Выполняют код и архитектурные задачи
  - Анализируют документацию проекта (глубокий анализ)
  - Создают планы выполнения (deep thinking)
  - Пишут тесты и проводят ревью
  - **Подробно протоколируют работу** - создают детальные отчеты
  - Генерируют отчеты о выполнении с полным контекстом

### Процесс работы с документацией

- **Code Agent**: Только проверяет наличие файлов в `docs/`, не читает их полностью
- **Cursor Agents**: Вся работа с документацией (чтение, анализ, обновление) выполняется агентами Cursor
- **LLM в Code Agent** (слабая модель): Анализирует только задачи из todo-листа простыми действиями:
  - Парсинг текста задачи
  - Определение типа задачи по ключевым словам
  - Выбор шаблона инструкции из конфигурации
  - **НЕ делает deep thinking** или сложный анализ

## Интерфейс взаимодействия с Cursor

### Способы взаимодействия (приоритет реализации)

- [План реализации](../planning/implementation_roadmap.md)
- [Резюме исправлений](../solutions/INTEGRATION_FIX_SUMMARY.md)
- [Решения проблем](../solutions/CURSOR_INTEGRATION_SOLUTIONS.md)
- [Быстрый старт: Гибридный интерфейс](../guides/QUICK_START_HYBRID.md)

Code Agent может взаимодействовать с Cursor через следующие способы (в порядке приоритета реализации):

#### 1. ✅ Файловая система (РЕКОМЕНДУЕТСЯ НАЧАТЬ С ЭТОГО)

**Приоритет:** ВЫСОКИЙ - Начать с этого  
**Сложность:** Низкая  
**Зависимости:** Нет

- ✅ Не требует API ключей
- ✅ Не требует установки дополнительных библиотек
- ✅ Работает сразу и надежно
- ✅ Не зависит от изменений интерфейса Cursor

**Как работает:**
- Code Agent создает файл `cursor_commands/instruction_{task_id}.txt` с инструкцией
- Пользователь (или расширение Cursor) читает файл и выполняет в Cursor
- Результат записывается в `cursor_results/result_{task_id}.txt` с контрольной фразой
- Code Agent читает результат и продолжает работу

**Реализация:** `src/cursor_file_interface.py`

#### 2. ✅ Cursor CLI (если доступен)

**Приоритет:** ВЫСОКИЙ - Второй этап  
**Сложность:** Средняя  
**Зависимости:** Cursor CLI должен быть установлен

- ✅ Автоматическое выполнение без участия пользователя
- ✅ Работа в headless режиме
- ⚠️ Требует установки Cursor CLI

**Реализация:** `src/cursor_cli_interface.py`

#### 3. ✅ Background Agents API (для репозиториев)

**Приоритет:** СРЕДНИЙ - Третий этап  
**Сложность:** Средняя  
**Зависимости:** Cursor API ключ

- ✅ Официальный API
- ✅ Работает только с GitHub репозиториями
- ⚠️ Требует API ключ

**Реализация:** `src/integration/cursor_client.py`

#### 4. ⚠️ UI автоматизация (в последнюю очередь)

**Приоритет:** НИЗКИЙ - Использовать как fallback  
**Сложность:** Высокая  
**Зависимости:** pyautogui, pytesseract, opencv-python, mss

- ⚠️ Хрупко и зависит от изменений интерфейса
- ⚠️ Требует точных координат элементов
- ⚠️ Может ломаться при обновлениях Cursor

**Способы:**
- **Скриншоты** - Анализ состояния интерфейса через визуальное распознавание
- **Управление мышью** - Клики и навигация по интерфейсу
- **Горячие клавиши** - Управление окном Cursor через keyboard shortcuts
- **Фокус окна** - Переключение фокуса на окно Cursor для управления

**Реализация:** `src/cursor_ui_interface.py`

### Структура окна Cursor

```
┌─────────────────────────────────────────────────────────┐
│                    Cursor IDE                           │
├─────────────┬───────────────────────┬───────────────────┤
│             │                       │                   │
│  Sidebar    │   Область кода        │  Область агента   │
│  - Дерево   │   (Открытые вкладки)  │  Cursor           │
│    проекта  │                       │  - Чат с агентом  │
│  - Git      │                       │  - Выбор диалога  │
│             │                       │  - Новый диалог   │
│             │                       │                   │
└─────────────┴───────────────────────┴───────────────────┘
```

**Важно**: Для каждого пункта todo создается **новый диалог** с агентом Cursor.

## Cursor API и программная интеграция

### Вопрос: Существует ли Cursor API?

**Ответ:** Cursor предоставляет несколько API для программного взаимодействия, но **не существует публичного API для прямого управления чатом** (создание/отправка сообщений через внешние команды).

### Что доступно официально

#### 1. Background Agents API

**Назначение:** Создание и управление автономными агентами для работы с репозиториями.

**Возможности:**
- ✅ Создание агентов для работы с GitHub репозиториями
- ✅ Отправка инструкций агентам для выполнения задач
- ✅ Получение статуса и истории выполнения
- ✅ Follow-up инструкции для существующих агентов
- ✅ Автономная работа над репозиторием (клонирование, ветки, коммиты, PR)

**Документация:** [docs.cursor.com](https://docs.cursor.com)

**Endpoints (примерно):**
```python
# Базовый URL
CURSOR_API_BASE = "https://api.cursor.com/v0"

# Основные endpoints:
# GET  /v0/agents              - Список всех агентов
# GET  /v0/agents/{id}         - Статус конкретного агента
# POST /v0/agents              - Создать нового агента
# POST /v0/agents/{id}/follow-up - Отправить follow-up инструкцию
```

**Ограничения:**
- Работает только с GitHub (GitLab/Bitbucket планируются)
- Не управляет локальным интерфейсом Cursor IDE
- Не создает чаты в открытом окне Cursor

#### 2. Admin API

**Назначение:** Управление командой и метриками.

**Возможности:**
- ✅ Управление командой (teams)
- ✅ Метрики использования и расходы
- ✅ Административные функции

**Использование:** Для корпоративных команд и управления подписками.

#### 3. AI Code Tracking API

**Назначение:** Аналитика по AI-сгенерированному коду.

**Возможности:**
- ✅ Аналитика по AI-сгенерированному коду
- ✅ Отчёты по коммитам и изменениям
- ✅ Метрики использования

**Использование:** Для отслеживания использования AI функций в проекте.

#### 4. Custom API Keys

**Назначение:** Подключение собственных ключей к моделям.

**Возможности:**
- ✅ Подключение собственных ключей к моделям (OpenAI, Anthropic и др.)
- ✅ Контроль расходов на API

**Ограничения:**
- Не даёт полноценного управления интерфейсом
- Только настройка источников моделей

### Что отсутствует

❌ **Публичный API для прямого управления чатом** (создание/отправка сообщений)  
❌ **API для полного контроля GUI через внешние команды**  
❌ **Публичный CLI API для всех функций Cursor**  
❌ **API для управления локальным окном Cursor IDE**

### Альтернативные подходы для Windows

#### 1. MCP (Model Context Protocol)

**Статус:** Уже используется в проекте (`.cursor/MCP_SETUP.md`)

**Описание:** Протокол для интеграции, но не прямой API управления Cursor.

**Использование:**
- Предоставление контекста проекту через MCP сервер
- Доступ к документации и коду через MCP
- **Не управляет интерфейсом Cursor напрямую**

#### 2. Автоматизация через UI

**Описание:** Использование Windows UI-автоматизации для взаимодействия с окнами Cursor.

**Библиотеки:**
- `pywinauto` - автоматизация Windows приложений
- `win32gui` - управление окнами Windows
- `pyautogui` - управление мышью и клавиатурой

**Ограничения:**
- ⚠️ Хрупко и зависит от изменений интерфейса
- ⚠️ Требует точных координат элементов
- ⚠️ Может ломаться при обновлениях Cursor

**Пример использования:**
```python
import pyautogui
import pygetwindow as gw

# Найти окно Cursor
windows = gw.getWindowsWithTitle("Cursor")
if windows:
    cursor_window = windows[0]
    cursor_window.activate()
    
    # Открыть новый чат (Ctrl+Shift+P)
    pyautogui.hotkey('ctrl', 'shift', 'p')
    # Ввести команду "New Chat"
    pyautogui.write("New Chat")
    pyautogui.press('enter')
```

#### 3. Cursor CLI (headless режим)

**Описание:** Использование командной строки Cursor для выполнения задач без UI.

**Команда:**
```bash
# Запуск агента через CLI
cursor-agent -p "ваша инструкция" --headless
```

**Возможности:**
- ✅ Выполнение задач без открытия GUI
- ✅ Автоматическая обработка через скрипты
- ✅ Интеграция с CI/CD

**Ограничения:**
- ⚠️ Не все функции доступны через CLI
- ⚠️ Требует установки Cursor CLI отдельно

**Пример использования:**
```python
import subprocess

def execute_cursor_cli(prompt: str, working_dir: str = None):
    """Выполнить команду через Cursor CLI."""
    cmd = ["cursor-agent", "-p", prompt]
    if working_dir:
        cmd.extend(["--cwd", working_dir])
    
    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        timeout=300,
        cwd=working_dir or os.getcwd()
    )
    
    return {
        "success": result.returncode == 0,
        "stdout": result.stdout,
        "stderr": result.stderr
    }
```

#### 4. Работа с файлами проекта

**Описание:** Cursor часто реагирует на изменения файлов в проекте.

**Подход:**
- Создание файлов-команд, которые Cursor может читать
- Мониторинг изменений файлов через `watchdog`
- Использование файловой системы как канала связи

**Пример:**
```python
# Code Agent создает файл-команду
with open("cursor_commands/instruction_001.txt", "w") as f:
    f.write("Выполни задачу: рефакторинг функции calculate_energy")

# Cursor расширение (если будет создано) читает файл
# и выполняет команду, записывая результат в:
# cursor_results/result_001.txt
```

### Рекомендации по интеграции

#### Для работы с кодом и документацией

✅ **Background Agents API** - для автономной работы с репозиториями  
✅ **Cursor CLI** - для автоматизации через командную строку

#### Для отчётов

✅ **AI Code Tracking API** - для аналитики и метрик

#### Для интеграции проекта

✅ **HTTP API проекта** (`main_server_api.py`) - уже работает  
✅ **MCP сервер** - для предоставления контекста

#### Для прямого управления чатом

❌ **Пока нет публичного API** - используйте альтернативные подходы:
- UI автоматизация (хрупко, но работает)
- Файловая система как канал связи
- Cursor CLI для headless режима

### Комбинированный подход

**Рекомендуемая схема работы:**

```
1. Внешний запрос → HTTP API проекта (main_server_api.py)
   ↓
2. API обращается к:
   - Cursor Background Agents API (для репозиториев)
   - Cursor CLI (для локальной работы)
   - UI автоматизация (для управления интерфейсом)
   ↓
3. Результаты сохраняются и доступны через:
   - MCP сервер
   - Файлы-репорты
   - HTTP API ответы
```

### Настройка переменных окружения

Для работы с Cursor API требуется:

```bash
# .env файл
CURSOR_API_KEY=your_api_key_here
CURSOR_API_BASE_URL=https://api.cursor.com/v0
CURSOR_CLI_PATH=cursor-agent  # или полный путь
```

### Примеры интеграции

#### Создание агента через Background Agents API

```python
import requests
import os

def create_cursor_agent(repository: str, instruction: str):
    """Создать агента через Background Agents API."""
    api_key = os.getenv("CURSOR_API_KEY")
    base_url = os.getenv("CURSOR_API_BASE_URL", "https://api.cursor.com/v0")
    
    response = requests.post(
        f"{base_url}/agents",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json={
            "repository": repository,
            "instruction": instruction
        }
    )
    
    return response.json()
```

#### Выполнение через Cursor CLI

```python
import subprocess

def execute_via_cli(prompt: str, working_dir: str = None):
    """Выполнить задачу через Cursor CLI."""
    cmd = ["cursor-agent", "-p", prompt]
    if working_dir:
        cmd.extend(["--cwd", working_dir])
    
    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        timeout=300
    )
    
    return result
```

### Что можно попробовать

1. ✅ **Проверить CLI команды Cursor** - возможно, есть недокументированные возможности
2. ✅ **Мониторить обновления документации Cursor** - на предмет новых API
3. ✅ **Использовать комбинацию Background Agents API + автоматизация UI** - для базовых операций
4. ✅ **Создать расширение для Cursor** - для программного взаимодействия (если будет необходимо)

### Важные замечания

⚠️ **Cursor установлен на компьютере и запущен в оконном режиме Windows**

- Пользователь легко взаимодействует с интерфейсом
- **Прямого API для управления чатом нет**
- Используйте комбинацию подходов:
  - Background Agents API для репозиториев
  - UI автоматизация для локального интерфейса
  - Cursor CLI для headless режима
  - Файловая система как канал связи

### Следующие шаги

1. Изучить Background Agents API подробнее
2. Настроить интеграцию с доступными API
3. Реализовать UI автоматизацию для базовых операций
4. Создать модуль интеграции в проекте (`src/integration/cursor_client.py`)
5. Расширить HTTP API сервер новыми endpoints для работы с Cursor

## Подробный процесс выполнения задачи

### Общая схема выполнения

```
1. Code Agent читает задачу из todo.txt
   ↓
2. Code Agent проверяет наличие файлов в docs/ (без чтения)
   ↓
3. LLM (слабая модель) анализирует задачу простыми действиями:
   - Парсинг текста задачи
   - Определение типа задачи по ключевым словам
   - Выбор шаблона инструкции из конфигурации
   (БЕЗ deep thinking или сложного анализа)
   ↓
4. LLM генерирует инструкции для Cursor используя предопределенные шаблоны
   (НЕ создает новые планы, только использует шаблоны из конфигурации)
   ↓
5. Code Agent взаимодействует с Cursor через интерфейс
   ↓
6. Cursor Agents выполняют работу (код, тесты, документация, deep thinking)
   ↓
7. **Cursor выполняет работу** - используя мощные модели, понимает контекст с полуслова
   - Подробно протоколирует работу в файлах-репортах
   - Создает детальные отчеты с полным контекстом
   - Добавляет контрольные фразы для синхронизации
   ↓
8. **Code Agent получает результаты** - читает текстовые репорты из файлов
   - **Важно:** Code Agent дожидается создания файлов-репортов
   - Проверяет наличие файлов с определенными интервалами
   - Читает содержимое репортов для проверки выполнения
   ↓
9. LLM (слабая модель) проверяет результаты простыми проверками:
   - Наличие файла-репорта
   - Контрольная фраза в отчете
   - Простая валидация формата
   (БЕЗ глубокого анализа содержимого)
   ↓
9. Code Agent обновляет status в codeAgentProjectStatus.md
```

### Детальная схема выполнения одного пункта todo

#### Инструкция 1: Начало работы и создание плана

**Действие Code Agent:**
- Создает новый диалог с агентом Cursor
- Отправляет инструкцию для выполнения задачи

**Инструкция для Cursor:**
```
Переходим к выполнению задачи "5. Создание клиентского слоя через web front, и т.д."

1. Изучи связанную документацию по проекту
2. Создай план выполнения текущей задачи в файле docs/results/current_plan_5.1.md 
   (5.1 - это итератор из листа todo)
3. Создай краткий отчет о проделанной работе в docs/results/last_result.md
```

**Отчет Cursor:**
- Создается файл `docs/results/current_plan_5.1.md` с планом
- Создается файл `docs/results/last_result.md` с кратким отчетом
- В конце отчета должна быть контрольная фраза: **"Отчет завершен!"**

**Контроль Code Agent:**
- Проверяет наличие файла `docs/results/last_result.md`
- Проверяет наличие контрольной фразы "Отчет завершен!"
- Если файл отсутствует или фраза не найдена - ожидает (проверка по скриншоту или таймаут)

---

#### Инструкция 2: Последовательное выполнение плана

**Действие Code Agent:**
- Читает план из `docs/results/current_plan_5.1.md`
- Разбивает план на отдельные пункты
- Последовательно ставит задачи перед Cursor

**Инструкции для Cursor** (по каждому пункту плана):
```
Выполни пункт N из плана current_plan_5.1.md:
[Описание пункта плана]

Сохрани промежуточный отчет в docs/results/plan_result_5.1.md
В конце отчета напиши "Отчет завершен!"
```

**Отчет Cursor:**
- Обновляется файл `docs/results/plan_result_5.1.md` с результатами
- В конце отчета: **"Отчет завершен!"**

**Контроль Code Agent:**
- После каждого пункта плана проверяет `plan_result_5.1.md`
- Ждет контрольную фразу перед переходом к следующему пункту
- Взаимодействует с Cursor на протяжении всего плана

---

#### Инструкция 3: Тестирование

**Действие Code Agent:**
- После завершения плана создает новый диалог с Cursor
- Отправляет инструкцию на тестирование

**Инструкция для Cursor:**
```
Покрой тестами новую функциональность:
- Статические тесты
- Дымовые тесты
- Интеграционные тесты

ВАЖНО: Обязательно выполни все пункты и создай файл отчета!

1. Напиши тесты в src/test/ (или обнови существующие тесты)
2. Запусти тесты и проверь результаты
3. ОБЯЗАТЕЛЬНО создай файл отчета: docs/results/test_{task_id}.md
   В отчете укажи:
   - Какие тесты были созданы/обновлены
   - Результаты запуска тестов
   - Выявленные проблемы (если есть)
4. В конце файла отчета ОБЯЗАТЕЛЬНО напиши: "Тестирование завершено!"

Файл docs/results/test_{task_id}.md должен быть создан обязательно!
```

**Отчет Cursor:**
- Тесты создаются в `src/test/`
- Результаты тестирования в `docs/results/test_{task_id}.md`
- Контрольная фраза: **"Тестирование завершено!"**

**Контроль Code Agent:**
- Проверяет наличие ошибок в отчете
- Если есть ошибки - отправляет инструкцию на исправление
- Повторяет до 3 попыток исправления ошибок
- Если ошибки остаются - фиксирует в `codeAgentProjectStatus.md` и переходит дальше
- **Улучшено (2026-01-19)**: Добавлена проверка альтернативных имен файлов (test_{task_id}.md, test_task_{task_id}.md) для большей гибкости

---

#### Инструкция 4: Обновление документации

**Действие Code Agent:**
- Создает новый диалог с Cursor

**Инструкция для Cursor:**
```
Создай/обнови текущую документацию с учетом всех последних доработок.

Модифицированные файлы можно увидеть через git:
- git status
- git diff

Обнови соответствующие файлы документации и отчитайся о выполненных действиях.
Отчет в docs/results/last_result.md, в конце "Отчет завершен!"
```

**Отчет Cursor:**
- Обновляет файлы документации в `docs/`
- Создает/обновляет `docs/results/last_result.md`

---

#### Инструкция 5: Ревью Скептика

**Действие Code Agent:**
- Создает новый диалог с Cursor
- Просит агента выступить в роли Скептика

**Инструкция для Cursor:**
```
Проанализируй текущие доработки и документацию в рамках текущей задачи.

Напиши ревью в файле docs/reviews/skeptic_5.1_18.01.26.md 
(имя файла: пункт плана + текущая дата)

Интересуют:
- Любые недоработки
- Отклонения от плана
- Проблемы в коде или документах
- Сомнительный код или документы
- Все что тебя смущает или противоречит

Опиши все в подробном репорте.
В конце напиши фразу с новой строки: "Отчет готов!"
```

**Отчет Cursor:**
- Создается файл `docs/reviews/skeptic_5.1_18.01.26.md`
- Контрольная фраза: **"Отчет готов!"**

---

#### Инструкция 6: Реализация доработок по ревью Скептика

**Действие Code Agent:**
- Читает ревью от Скептика
- Создает новый диалог с агентом-Архитектором Cursor

**Инструкция для Cursor:**
```
Проанализируй репорт от Скептика из файла docs/reviews/skeptic_5.1_18.01.26.md

Составь новый план реализации/исправления выявленных проблем.

Приступаем к реализации доработок по пункту 5.1 после отчета скептика.
```

**Процесс:**
- Организуется цепочка выполнения и отчетов для Code Agent
- Несколько итераций с новыми инструкциями
- После каждого шага - отчет в `docs/results/`

---

#### Инструкция 7: Обновление документации после доработок

**Действие Code Agent:**
- Создает новый диалог с Cursor

**Инструкция для Cursor:**
```
Обнови документацию по доработкам, выполненным после ревью Скептика.

Отчет в docs/results/last_result.md, в конце "Отчет завершен!"
```

---

#### Инструкция 8: Полное тестирование проекта

**Действие Code Agent:**
- Создает новый диалог с Cursor

**Инструкция для Cursor:**
```
Запусти все тесты из каталога src/test

Agent CLI должен
1. Выполнить требуемые команды для запуска тестов (ты сам знаешь какие)
2. Создать репорты об ошибках по результатам полного тестирования
3. Отчет в docs/results/test_full_5.1.md
4. В конце "Тестирование завершено!"
```

**Контроль Code Agent:**
- Проверяет наличие ошибок в отчете
- Если тесты не пройдены:
  - Просит агента Cursor исправить ошибки
  - Просит перезапустить отдельные тесты
  - До 3 попыток исправления ошибок
- Если проблемы остаются - фиксирует в `codeAgentProjectStatus.md` и переходит дальше

---

#### Инструкция 9: Коммит и отправка

**Действие Code Agent:**
- Создает новый диалог с Cursor

**Инструкция для Cursor:**
```
Создай новый коммит и зафиксируй коммит с подробным текстом.

Включи в коммит все модифицированные файлы.

Отправь коммит в удаленный репозиторий!
```

**Результат:**
- Все изменения закоммичены
- Коммит отправлен в удаленный репозиторий
- Код Agent фиксирует это в `codeAgentProjectStatus.md`

---

## Взаимодействие через репорты

⚠️ **Важно:** Code Agent должен **правильно дожидаться выполнения работы** Cursor через механизм файлов-репортов.

### Процесс ожидания

1. **Code Agent отправляет инструкцию** Cursor
2. **Code Agent начинает ожидание** - проверяет файлы-репорты через интервалы
3. **Cursor выполняет работу** - используя мощные модели, понимает контекст с полуслова
4. **Cursor создает файл-репорт** - подробно документирует выполнение
5. **Cursor добавляет контрольную фразу** - для синхронизации с Code Agent
6. **Code Agent проверяет репорт** - наличие файла и контрольной фразы
7. **Code Agent переходит к следующему шагу** - только после подтверждения

### Почему это важно

- Cursor использует **мощные модели**, которые могут выполнять сложную работу
- Cursor **понимает контекст с полуслова** - не требует детальных инструкций
- Cursor может **подробно протоколировать работу** - создает детальные отчеты
- Code Agent должен **правильно дожидаться** - не прерывать работу Cursor
- Файлы-репорты - это **единственный канал связи** между агентами

Подробнее см. [Взаимодействие через репорты](../guides/CURSOR_RESULTS_MECHANISM.md)

## Формат файла codeAgentProjectStatus.md

`codeAgentProjectStatus.md` - это **последовательный протокол** всех действий Code Agent и ответов агентов Cursor.

### Структура записей

```markdown
## [2025-01-26 14:30:15] Задача: 5. Создание клиентского слоя

### Инструкция 1: Создание плана
**Время:** 2025-01-26 14:30:15
**Действие:** Отправлена инструкция Cursor для создания плана
**Инструкция:**
> Переходим к выполнению задачи "5. Создание клиентского слоя..."
> ...

**Ожидание:** Проверка файла docs/results/last_result.md

**Результат от Cursor:**
- Создан файл docs/results/current_plan_5.1.md
- Создан файл docs/results/last_result.md
- Контрольная фраза найдена: "Отчет завершен!"
**Время завершения:** 2025-01-26 14:35:20

---

### Инструкция 2: Выполнение пункта 1 плана
**Время:** 2025-01-26 14:35:25
**Действие:** Выполнение пункта 1 из current_plan_5.1.md
**Результат от Cursor:**
- Обновлен docs/results/plan_result_5.1.md
- Контрольная фраза найдена: "Отчет завершен!"
**Время завершения:** 2025-01-26 14:40:10

---

### Инструкция 3: Тестирование
**Время:** 2025-01-26 15:00:00
**Действие:** Запрос на тестирование функциональности
**Результат от Cursor:**
- Тесты созданы в src/test/
- Отчет создан: docs/results/test_5.1.md
- Ошибок не обнаружено
- Контрольная фраза: "Тестирование завершено!"
**Время завершения:** 2025-01-26 15:15:30

---

...
```

### Формат для каждой записи

- **Дата и время** - когда Code Agent выполнил действие
- **Задача** - номер и описание из todo-листа
- **Инструкция** - номер инструкции (1-9 или кастомная)
- **Действие Code Agent** - что было сделано
- **Инструкция для Cursor** - текст инструкции
- **Результат от Cursor** - краткий репорт из файлов-репортов
- **Время завершения** - когда Cursor завершил работу

## Конфигурация инструкций

Инструкции для каждой задачи можно настроить в `config/config.yaml`:

```yaml
instructions:
  # Шаблон инструкций для выполнения задачи
  default:
    - instruction_id: 1
      name: "Создание плана"
      template: |
        Переходим к выполнению задачи "{task_name}"
        1. Изучи связанную документацию
        2. Создай план в docs/results/current_plan_{task_id}.md
        3. Отчет в docs/results/last_result.md
      wait_for_file: "docs/results/last_result.md"
      control_phrase: "Отчет завершен!"
    
    - instruction_id: 2
      name: "Выполнение плана"
      # ...
```

## Иерархические планы

Code Agent поддерживает иерархические планы с разветвлением:

```
План задачи 5.1:
  ├─ Подзадача 5.1.1
  │   ├─ Шаг 1
  │   └─ Шаг 2
  ├─ Подзадача 5.1.2
  │   └─ Шаг 1
  └─ Подзадача 5.1.3 (если нужно)
      ├─ Шаг 1
      └─ Шаг 2
```

Code Agent может:
- Обрабатывать вложенные планы
- Разветвлять выполнение на основе условий
- Создавать параллельные ветки выполнения
- Объединять результаты веток

## Контрольные фразы

Cursor Agents должны использовать контрольные фразы в конце отчетов для синхронизации:

- `"Отчет завершен!"` - для обычных отчетов
- `"Тестирование завершено!"` - для отчетов о тестировании
- `"Отчет готов!"` - для ревью Скептика
- `"План готов!"` - для планов выполнения
- `"Коммит выполнен!"` - для подтверждения коммита

Code Agent проверяет наличие этих фраз перед переходом к следующему шагу.

## Обработка ошибок

### Ошибки в выполнении

Если Cursor сообщает об ошибке:
1. Code Agent фиксирует ошибку в `codeAgentProjectStatus.md`
2. Отправляет инструкцию Cursor на исправление
3. Ожидает результат исправления
4. До 3 попыток исправления (настраивается в конфиге)
5. Если не исправлено - фиксирует и переходит дальше

### Отсутствие файлов-репортов

Если файл-репорт не создан:
1. Code Agent проверяет через интерфейс Cursor (скриншот/состояние)
2. Если Cursor все еще работает - ожидает (таймаут настраивается)
3. Если таймаут истек - фиксирует проблему и переходит дальше

## Будущие улучшения

### Интеграция с Cursor API

- [x] Изучена документация Background Agents API
- [ ] Реализован модуль интеграции с Cursor API (`src/integration/cursor_client.py`)
- [ ] Расширен HTTP API сервер endpoints для работы с Cursor
- [ ] Настроена работа с Background Agents API для репозиториев
- [ ] Интеграция с Cursor CLI для headless режима
- [ ] Мониторинг обновлений Cursor API документации

### Автоматизация интерфейса

- [ ] Автоматическое распознавание состояния Cursor через скриншоты
- [ ] Управление мышью для создания новых диалогов
- [ ] Горячие клавиши для быстрого взаимодействия
- [ ] UI автоматизация через pywinauto/win32gui
- [ ] Обработка ошибок UI автоматизации

### Функциональность

- [ ] Параллельное выполнение независимых задач
- [ ] Динамическое изменение инструкций на основе результатов
- [ ] Интеграция с AI Code Tracking API для аналитики
- [ ] Создание расширения для Cursor (если потребуется)
- [ ] Использование файловой системы как канала связи

### Примечания

⚠️ **Публичный API для прямого управления чатом пока отсутствует.**  
Используйте комбинацию доступных подходов:
- Background Agents API для репозиториев
- UI автоматизация для локального интерфейса
- Cursor CLI для headless режима
- Файловая система как канал связи