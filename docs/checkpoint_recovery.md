# Система контрольных точек и восстановления после сбоев

## Обзор

Code Agent оснащен надежной системой контрольных точек (checkpoint), которая обеспечивает безопасное восстановление работы после сбоев, перезапусков или аварийных остановов сервера. Система гарантирует, что никакая работа не будет потеряна, а выполнение задач продолжится с последней сохраненной точки.

## Основные возможности

### 1. Автоматическое сохранение состояния

Система автоматически сохраняет:
- Состояние сервера (запущен/остановлен)
- Список всех задач и их статусы
- Текущую выполняемую задачу
- Количество попыток выполнения каждой задачи
- Информацию об ошибках
- Счетчик итераций

### 2. Защита от потери данных

- **Резервное копирование**: Перед каждым сохранением создается backup файл
- **Восстановление из backup**: При повреждении основного файла автоматически используется backup
- **Атомарные операции**: Все изменения сохраняются атомарно

### 3. Обнаружение сбоев

При запуске сервер автоматически определяет:
- Был ли предыдущий останов корректным
- Есть ли прерванные задачи
- Какие задачи остались незавершенными
- Какие задачи завершились с ошибками

### 4. Умное восстановление

- **Продолжение с последней точки**: Сервер продолжает работу с момента остановки
- **Защита от дублирования**: Завершенные задачи не выполняются повторно
- **Повторные попытки**: Задачи с ошибками могут быть повторены (настраивается)
- **Сброс прерванных задач**: Прерванные задачи автоматически возвращаются в очередь

## Архитектура

### Файлы checkpoint

```
.codeagent_checkpoint.json         # Основной файл контрольных точек
.codeagent_checkpoint.json.backup  # Резервная копия
```

### Структура данных checkpoint

```json
{
  "version": "1.0",
  "server_state": {
    "last_start_time": "2026-01-18T10:30:00",
    "last_stop_time": "2026-01-18T12:45:00",
    "iteration_count": 42,
    "clean_shutdown": true
  },
  "tasks": [
    {
      "task_id": "task_001",
      "task_text": "Реализовать функцию X",
      "state": "completed",
      "start_time": "2026-01-18T10:31:00",
      "end_time": "2026-01-18T10:35:00",
      "attempts": 1,
      "error_message": null,
      "metadata": {}
    }
  ],
  "current_task": null,
  "session_id": "20260118_103000",
  "last_update": "2026-01-18T12:45:00"
}
```

### Состояния задач

```python
class TaskState(Enum):
    PENDING = "pending"           # Ожидает выполнения
    IN_PROGRESS = "in_progress"   # В процессе выполнения
    COMPLETED = "completed"       # Успешно завершена
    FAILED = "failed"             # Завершена с ошибкой
    ROLLED_BACK = "rolled_back"   # Откачена
```

## Использование

### Автоматическая работа

Система checkpoint работает полностью автоматически. При запуске сервера:

1. Загружается checkpoint файл
2. Проверяется корректность предыдущего останова
3. Если обнаружен сбой:
   - Выводится детальная информация о состоянии
   - Прерванные задачи сбрасываются для повторного выполнения
   - Незавершенные задачи остаются в очереди
4. Сервер продолжает работу с последней точки

### Конфигурация

В `config/config.yaml`:

```yaml
server:
  checkpoint:
    # Включить систему checkpoint
    enabled: true
    
    # Файл для хранения контрольных точек
    checkpoint_file: ".codeagent_checkpoint.json"
    
    # Максимальное количество попыток выполнения задачи
    max_task_attempts: 3
    
    # Количество завершенных задач для хранения в checkpoint
    keep_completed_tasks: 100
```

### Программное использование

```python
from src.checkpoint_manager import CheckpointManager

# Создание менеджера
checkpoint = CheckpointManager(project_dir, checkpoint_file=".checkpoint.json")

# Отметка запуска сервера
checkpoint.mark_server_start(session_id="session_001")

# Добавление задачи
checkpoint.add_task("task_001", "Реализовать функцию", metadata={})

# Начало выполнения
checkpoint.mark_task_start("task_001")

# Успешное завершение
checkpoint.mark_task_completed("task_001", result={"status": "ok"})

# Или ошибка
checkpoint.mark_task_failed("task_001", "Ошибка выполнения")

# Корректный останов
checkpoint.mark_server_stop(clean=True)
```

## Сценарии восстановления

### Сценарий 1: Аварийная остановка (Ctrl+C)

```
1. Пользователь нажимает Ctrl+C
2. Сервер перехватывает сигнал
3. Отмечает корректный останов в checkpoint
4. Сохраняет текущее состояние
5. Завершает работу
```

При следующем запуске:
```
✓ Предыдущий останов был корректным
✓ Восстановление не требуется
✓ Продолжение с последней итерации
```

### Сценарий 2: Сбой питания / Crash

```
1. Сервер внезапно останавливается
2. Checkpoint остается с флагом clean_shutdown=False
3. Текущая задача остается в состоянии IN_PROGRESS
```

При следующем запуске:
```
⚠ ОБНАРУЖЕН НЕКОРРЕКТНЫЙ ОСТАНОВ СЕРВЕРА
⚠ Прерванная задача: Реализовать API endpoint
  - ID: task_12345
  - Попыток: 1
  - Начало: 2026-01-18 10:30:00
⚠ Незавершенных задач: 5
⚠ Задач с ошибками: 0

✓ Прерванная задача сброшена для повторного выполнения
✓ Сервер продолжит работу с последней контрольной точки
```

### Сценарий 3: Повреждение checkpoint файла

```
1. Основной checkpoint файл поврежден
2. Система обнаруживает ошибку при загрузке
3. Автоматически загружается backup файл
4. Работа продолжается с backup данных
```

Лог:
```
ERROR: Ошибка загрузки checkpoint: invalid JSON
INFO: Попытка восстановления из backup файла
INFO: Успешно восстановлено из backup
```

### Сценарий 4: Повторяющиеся ошибки задачи

```
1. Задача выполняется и завершается с ошибкой
2. Checkpoint сохраняет ошибку и увеличивает счетчик попыток
3. При следующей итерации задача выполняется снова
4. После 3 неудачных попыток (по умолчанию) задача пропускается
```

## Мониторинг и отладка

### Просмотр состояния checkpoint

```python
# Получить информацию о восстановлении
recovery_info = checkpoint.get_recovery_info()
print(f"Чистый останов: {recovery_info['was_clean_shutdown']}")
print(f"Незавершенных задач: {recovery_info['incomplete_tasks_count']}")
print(f"Задач с ошибками: {recovery_info['failed_tasks_count']}")

# Получить статистику
stats = checkpoint.get_statistics()
print(f"Всего задач: {stats['total_tasks']}")
print(f"Завершено: {stats['completed']}")
print(f"С ошибками: {stats['failed']}")
print(f"Итераций: {stats['iteration_count']}")
```

### Логи восстановления

При обнаружении сбоя в логах появляется детальная информация:

```
2026-01-18 10:00:00 - WARNING - ================================================================================
2026-01-18 10:00:00 - WARNING - ОБНАРУЖЕН НЕКОРРЕКТНЫЙ ОСТАНОВ СЕРВЕРА
2026-01-18 10:00:00 - WARNING - ================================================================================
2026-01-18 10:00:00 - WARNING - Последний запуск: 2026-01-18T09:30:00
2026-01-18 10:00:00 - WARNING - Последний останов: None
2026-01-18 10:00:00 - WARNING - Сессия: 20260118_093000
2026-01-18 10:00:00 - WARNING - Итераций выполнено: 15
2026-01-18 10:00:00 - WARNING - Прерванная задача: Реализовать логирование
2026-01-18 10:00:00 - WARNING -   - ID: task_1737187800
2026-01-18 10:00:00 - WARNING -   - Попыток: 1
2026-01-18 10:00:00 - WARNING -   - Начало: 2026-01-18T09:45:00
2026-01-18 10:00:00 - INFO - Прерванная задача сброшена для повторного выполнения
2026-01-18 10:00:00 - WARNING - Незавершенных задач: 3
2026-01-18 10:00:00 - WARNING -   - Добавить тесты (состояние: pending)
2026-01-18 10:00:00 - WARNING -   - Обновить документацию (состояние: pending)
2026-01-18 10:00:00 - WARNING - ================================================================================
2026-01-18 10:00:00 - INFO - Сервер продолжит работу с последней контрольной точки
2026-01-18 10:00:00 - WARNING - ================================================================================
```

## Обслуживание

### Очистка старых задач

Система автоматически очищает старые завершенные задачи каждые 10 итераций:

```python
# Автоматическая очистка (в server.py)
if iteration % 10 == 0:
    checkpoint_manager.clear_old_tasks(keep_last_n=100)
```

Это предотвращает неограниченный рост checkpoint файла.

### Ручная очистка

```python
# Очистить все старые задачи, оставить последние 50
checkpoint.clear_old_tasks(keep_last_n=50)

# Получить только незавершенные задачи
incomplete = checkpoint.get_incomplete_tasks()

# Получить только задачи с ошибками
failed = checkpoint.get_failed_tasks()
```

### Сброс checkpoint

Если нужно начать с чистого листа:

```bash
# Удалить checkpoint файлы
rm .codeagent_checkpoint.json
rm .codeagent_checkpoint.json.backup
```

При следующем запуске будет создан новый checkpoint.

## Безопасность и надежность

### Гарантии

1. **Атомарность**: Все операции записи атомарны
2. **Резервирование**: Автоматическое создание backup
3. **Восстановление**: Автоматическое восстановление из backup
4. **Защита от дублирования**: Завершенные задачи не выполняются повторно
5. **Отказоустойчивость**: Работа продолжается даже при повреждении данных

### Ограничения

1. **Размер файла**: При большом количестве задач файл может вырасти (используйте автоочистку)
2. **Производительность**: Каждое сохранение - операция I/O (оптимизировано для минимальных задержек)
3. **Одновременный доступ**: Не поддерживается запуск нескольких серверов с одним checkpoint

## Лучшие практики

1. **Не удаляйте checkpoint файлы вручную** во время работы сервера
2. **Регулярно проверяйте логи** на наличие предупреждений о восстановлении
3. **Настройте max_task_attempts** в зависимости от типа задач
4. **Используйте автоочистку** для контроля размера checkpoint
5. **Сохраняйте backup checkpoint** при критических операциях

## Интеграция с другими компонентами

### SessionTracker

Checkpoint работает совместно с SessionTracker для отслеживания сессий генерации TODO:

```python
session_id = session_tracker.current_session_id
checkpoint.mark_server_start(session_id)
```

### StatusManager

Информация о восстановлении автоматически записывается в статус файл:

```python
self.status_manager.append_status(
    f"Восстановление после сбоя. Незавершенных задач: {incomplete_count}",
    level=2
)
```

### TaskLogger

Каждая задача логируется как в TaskLogger, так и в Checkpoint:

```python
task_logger = TaskLogger(task_id, task_text)
checkpoint.mark_task_start(task_id)
```

## Тестирование

Полный набор тестов доступен в `test/test_checkpoint_recovery.py`:

```bash
# Запуск тестов checkpoint
pytest test/test_checkpoint_recovery.py -v

# Запуск конкретного теста
pytest test/test_checkpoint_recovery.py::test_crash_recovery -v
```

Тесты покрывают:
- Инициализацию и сохранение
- Жизненный цикл задач
- Восстановление после сбоя
- Защиту от дублирования
- Повторные попытки
- Восстановление из backup
- Очистку старых задач
- Статистику

## Заключение

Система контрольных точек обеспечивает надежную защиту от потери данных и автоматическое восстановление после любых сбоев. Она работает прозрачно для пользователя и не требует ручного вмешательства, гарантируя безопасное продолжение работы с последней точки остановки.
