# Архитектура Code Agent

## Обзор

Code Agent - это автоматизированная система на базе фреймворка CrewAI, предназначенная для управления и выполнения задач в проектах разработки. Агент работает в бесконечном цикле, анализирует документацию проекта, читает задачи из todo-листа и выполняет их поэтапно.

## Архитектурные компоненты

### 1. Ядро системы (`src/core/`)

#### 1.1 ServerCore (`src/core/server_core.py`)

**Ядро цикла выполнения задач с Dependency Injection:**

`ServerCore` является центральным компонентом, оркестрирующим основной цикл выполнения задач. Он фокусируется на координации различных менеджеров и обработчиков, предоставляемых через Dependency Injection, а не на непосредственной реализации сложной логики.

**Ключевые обязанности:**
- **Управление итерациями:** Координация полного цикла выполнения задач, включая задержки и обработку сигналов остановки/перезапуска.
- **Синхронизация задач:** Обеспечение согласованности между списком TODO и системой контрольных точек (checkpoint).
- **Обработка сценариев отсутствия задач:** Запуск ревизии проекта и, при необходимости, автоматическая генерация нового TODO-листа.
- **Делегирование выполнения:** Передача конкретных задач внешним обработчикам (например, LLM-системе или CrewAI) для выполнения.
- **Интеграция LLM:** Предоставление доступа к LLMManager для выполнения задач и анализа ошибок.

**Основные методы (высокоуровневые):**
- `execute_full_iteration(...)` - Выполнение одной полной итерации, включая загрузку, фильтрацию и выполнение задач, а также обработку сценариев отсутствия задач.
- `_sync_todos_with_checkpoint()` - Синхронизация статусов задач между TODO-листом и чекпоинтами.
- `_filter_completed_tasks()` - Фильтрация задач, уже выполненных согласно чекпоинтам.
- `_handle_no_tasks_scenario()` - Логика действий, когда в TODO-листе нет активных задач (ревизия, генерация TODO).
- `_load_documentation()` - Динамическая загрузка документации проекта для предоставления контекста LLM.
- `get_llm_manager()` - Предоставление инициализированного LLMManager другим компонентам.

**Dependency Injection (DI):**
`ServerCore` полностью построен на принципах Dependency Injection. Все внешние зависимости (менеджеры, обработчики) передаются через его конструктор, что обеспечивает:
- **Слабую связанность:** Компоненты легко заменяемы и независимы друг от друга.
- **Тестируемость:** Возможность легко подставлять mock-объекты для тестирования.
- **Гибкость:** Простая адаптация к новым реализациям или изменениям в поведении.

**Инжектируемые зависимости (пример):**
- `todo_manager: ITodoManager`
- `checkpoint_manager: ICheckpointManager`
- `status_manager: IStatusManager`
- `server_logger: ILogger`
- `task_executor: Callable[..., Any]` (может быть как CrewAI, так и LLM-система)
- `revision_executor: Callable[..., Any]`
- `todo_generator: Callable[..., Any]`
- `verification_manager: IMultiLevelVerificationManager`
- `llm_manager: Optional[Any]` (экземпляр NewLLMManager или LegacyLLMManager)

#### 1.2 Абстрактные базовые классы (`src/core/abstract_base.py`)

**Иерархия компонентов:**
- `BaseComponent` - Базовый компонент, наследующий `IServerComponent`
- `ConfigurableComponent` - Конфигурируемый компонент с поддержкой `IConfigurable`
- `MetricsEnabledComponent` - Компонент с поддержкой метрик `IMetricsCollector`

### 1.3 Интерфейсы и Dependency Injection (`src/core/interfaces/`)

**Принципы SOLID и DI:**

Система построена на принципах SOLID и dependency injection для обеспечения:
- **S (Single Responsibility)**: Каждый компонент отвечает за одну задачу
- **O (Open/Closed)**: Компоненты открыты для расширения, закрыты для модификации
- **L (Liskov Substitution)**: Реализации могут заменяться через интерфейсы
- **I (Interface Segregation)**: Разделение интерфейсов по ответственности
- **D (Dependency Inversion)**: Зависимости инжектируются, а не создаются

**Основные интерфейсы:**
- `IManager` - Базовый интерфейс для всех менеджеров
- `ITodoManager` - Управление задачами проекта
- `IStatusManager` - Управление статусами выполнения
- `ICheckpointManager` - Управление контрольными точками
- `ILogger` - Логирование операций
- `IServer` - Управление жизненным циклом сервера
- `IAgent` - Управление агентами CrewAI
- `ITaskManager` - Управление выполнением задач

**Dependency Injection контейнер (`src/core/di_container.py`):**
- `DIContainer` - Контейнер для регистрации и разрешения зависимостей
- `ServiceLifetime` - SINGLETON, TRANSIENT, SCOPED
- `create_default_container()` - Фабрика для создания настроенного контейнера
- **IQualityGateManager** - Регистрация Quality Gates framework
- **Фабрика QualityGateManager** - Создание с настраиваемой конфигурацией

#### 1.3 Интерфейсы (`src/core/interfaces/`)

**Основные интерфейсы системы:**
- `IManager` - Базовый интерфейс для всех менеджеров с общими методами жизненного цикла
- `ITodoManager` - Управление задачами проекта (чтение, парсинг, обновление todo-листов)
- `IStatusManager` - Управление статусами выполнения задач
- `ICheckpointManager` - Управление контрольными точками и восстановлением состояния
- `ILogger` - Логирование операций с поддержкой разных уровней и структурированных данных
- `IServer` - Управление жизненным циклом сервера и координация компонентов
- `IAgent` - Управление агентами CrewAI (создание, конфигурация, мониторинг)
- `ITaskManager` - Управление выполнением задач с состояниями и метриками

**Дополнительные типы:**
- `TaskExecutionState` - Перечисление состояний выполнения задач (PENDING, EXECUTING, COMPLETED, etc.)

**Mock-реализации для тестирования:**
- `MockServer` - Mock-реализация IServer для интеграционного тестирования
- `MockAgentManager` - Mock-реализация IAgent для тестирования управления агентов
- `MockTaskManager` - Mock-реализация ITaskManager для тестирования выполнения задач

#### 1.4 Quality Gates Framework (`src/quality/`)

**Система контроля качества кода и выполнения задач:**

**Архитектура Quality Gates:**
- **IQualityGate** - Интерфейс для отдельных quality gates
- **IQualityChecker** - Интерфейс для различных проверок качества
- **IQualityReporter** - Интерфейс для отчетов о качестве
- **IQualityGateManager** - Менеджер quality gates

**Типы проверок качества:**
- **CoverageChecker**: Проверка покрытия тестами (pytest-cov интеграция)
- **ComplexityChecker**: Анализ цикломатической сложности (radon/mccabe)
- **SecurityChecker**: Проверка безопасности кода (bandit интеграция)
- **StyleChecker**: Проверка стиля кода (ruff, mypy, bandit)
- **TaskTypeChecker**: Валидация корректности типов задач проекта
- **DependencyChecker**: Проверка зависимостей проекта (импорты, requirements, конфликты)
- **ResourceChecker**: Мониторинг системных ресурсов (CPU, память, диск)
- **ProgressChecker**: Контроль прогресса выполнения задач (время, таймауты)

**Модели данных:**
- `QualityResult` - Результат отдельной проверки
- `QualityGateResult` - Агрегированный результат quality gate
- `QualityMetrics` - Комплексные метрики качества:
  - `CoverageMetrics` - Метрики покрытия тестами
  - `ComplexityMetrics` - Метрики сложности кода
  - `SecurityMetrics` - Метрики безопасности
  - `StyleMetrics` - Метрики стиля кода
  - `DependencyMetrics` - Метрики зависимостей проекта
  - `ResourceMetrics` - Метрики системных ресурсов
  - `ProgressMetrics` - Метрики прогресса выполнения

**Интеграция с основным циклом:**
- Quality gates проверяются перед выполнением задач
- Настраиваемые правила активации (по типам задач, уровням критичности)
- Режимы работы: strict (блокировка), warning (предупреждение), disabled
- Кэширование результатов для производительности

#### 1.5 Verification System (`src/verification/`)

**Система многоуровневой верификации результатов выполнения задач:**

**Архитектура Verification System:**
- **IMultiLevelVerificationManager** - Интерфейс менеджера многоуровневой верификации
- **IExecutionMonitor** - Интерфейс мониторинга выполнения задач
- **ILLMValidator** - Интерфейс AI-based валидации через LLM
- **MultiLevelVerificationManager** - Реализация менеджера верификации
- **ExecutionMonitor** - Реализация мониторинга выполнения
- **LLMValidator** - Реализация AI валидации

**Уровни верификации:**
- **Pre-execution**: Проверки перед выполнением (качество кода, зависимости, ресурсы)
- **In-execution**: Мониторинг выполнения в реальном времени
- **Post-execution**: Валидация результатов после выполнения
- **AI-validation**: Интеллектуальный анализ через LLM
- **Cross-validation**: Проверка согласованности между уровнями

**Модели данных верификации:**
- `VerificationResult` - Результат отдельного уровня верификации
- `MultiLevelVerificationResult` - Агрегированный результат всех уровней
- `VerificationLevel` - Перечисление уровней верификации

**Интеграция с Quality Gates:**
- Расширяет возможности Quality Gates новыми чекерами
- Добавляет временные аспекты верификации (pre/in/post execution)
- Интегрируется с существующей системой quality checks

**Конфигурация Quality Gates:**
```yaml
quality_gates:
  enabled: true
  strict_mode: false

  gates:
    coverage:
      enabled: true
      min_coverage: 80

    complexity:
      enabled: true
      max_complexity: 10

    security:
      enabled: true
      scan_dependencies: true

    style:
      enabled: true
      tools: ["ruff", "mypy", "bandit"]

    task_type:
      enabled: true
      max_untyped_percentage: 0.3
      min_typed_percentage: 0.7
      check_distribution: true

    dependency:
      enabled: true
      check_imports: true
      check_requirements: true
      check_conflicts: true

    resource:
      enabled: true
      min_cpu_percent: 10.0
      min_memory_percent: 20.0
      min_disk_percent: 10.0

    progress:
      enabled: true
      max_execution_time: 300
      progress_timeout: 60
```

#### 1.6 LLM Module (Новая модульная архитектура)

**Система управления LLM провайдерами с модульной архитектурой:**

**Архитектурные принципы:**
- **Модульность**: Разделение монолитного LLMManager на специализированные компоненты
- **Dependency Injection**: Слабая связанность через интерфейсы и DI
- **Single Responsibility**: Каждый компонент отвечает за одну задачу
- **Fault Tolerance**: Многоуровневая обработка ошибок и fallback цепочки

**Основные компоненты модульной архитектуры:**

##### LLMManager (Фасад)
**Центральный компонент системы:**
- Единый интерфейс для всех операций с LLM
- Управление жизненным циклом компонентов
- Dependency injection всех зависимостей
- Координация между компонентами

```python
class LLMManager:
    """Фасад для модульной архитектуры LLM компонентов"""

    def __init__(self, config_path: str = "config/llm_settings.yaml"):
        # Инициализация всех компонентов через DI
        self.config_loader = ConfigLoader(config_path)
        self.registry = ModelRegistry(self.config_loader)
        self.client = ClientManager(self.config_loader)
        self.strategy = StrategyManager(self.registry, self.client, ...)
        # ...

    async def generate_response(self, request: GenerationRequest) -> ModelResponse:
        # Делегирование StrategyManager
        return await self.strategy.generate(request)
```

##### ModelRegistry
**Управление реестром моделей:**
- Загрузка конфигурации моделей из YAML
- Управление ролями моделей (PRIMARY, DUPLICATE, RESERVE, FALLBACK)
- Статистика производительности моделей
- Выбор оптимальной модели по критериям

##### ClientManager
**Управление API клиентами:**
- Создание и кэширование клиентов для разных провайдеров
- Управление соединениями и аутентификацией
- Маршрутизация запросов к правильным провайдерам
- Обработка сетевых ошибок

##### StrategyManager
**Стратегии генерации ответов:**
- **Single Model**: Быстрая генерация через одну модель
- **Parallel Generation**: Одновременная генерация через несколько моделей
- **Fallback Chains**: Последовательное переключение при ошибках
- **Best-of-Two**: Выбор лучшего ответа из двух вариантов

##### ResponseEvaluator
**Оценка качества ответов:**
- Автоматическая оценка ответов по критериям качества
- Сравнение нескольких ответов
- Выбор оптимального ответа для пользователя
- Адаптивная оценка на основе контекста

##### JsonValidator
**Валидация JSON ответов:**
- Проверка корректности JSON структуры
- Извлечение JSON из markdown кода
- Исправление malformed JSON
- Обеспечение типобезопасности ответов

##### HealthMonitor
**Мониторинг здоровья системы:**
- Фоновый мониторинг доступности моделей
- Автоматическое отключение проблемных моделей
- Попытки восстановления упавших моделей
- Уведомления о проблемах со здоровьем

##### ConfigLoader
**Загрузка и валидация конфигурации:**
- Загрузка YAML конфигураций
- Подстановка переменных окружения
- Валидация структуры конфигурации
- Горячая перезагрузка настроек

#### 1.7 Интеллектуальные компоненты LLM модуля

**Система интеллектуальной интеграции LLM провайдеров с адаптивными возможностями:**

##### IntelligentRouter (Интеллектуальный роутер)
**Автоматический выбор оптимальных моделей:**
- Анализ контекста запросов и классификация типов задач
- Оценка сложности и требований к ответам (точность, креативность, скорость)
- Интеллектуальный выбор моделей на основе исторической производительности
- Обучение на результатах для улучшения маршрутизации
- Поддержка 12+ типов задач (кодогенерация, анализ, вопросы-ответы, JSON генерация и др.)

**Ключевые возможности:**
- Анализ текста запросов с извлечением ключевых слов
- Оценка сложности (простой/средний/сложный/очень сложный)
- Прогнозирование количества токенов
- Определение требований к качеству ответов
- Кэширование анализа для производительности

##### AdaptiveStrategyManager (Адаптивный менеджер стратегий)
**Динамическое переключение стратегий генерации:**
- Автоматический выбор между single/parallel/fallback/iterative стратегиями
- Адаптация на основе производительности и обратной связи
- Обучение на исторических данных для оптимизации выбора
- Детектирование паттернов низкой производительности
- Автоматическая корректировка стратегий

**Стратегии генерации:**
- **Single**: Быстрая генерация через одну модель
- **Parallel**: Одновременная генерация с выбором лучшего ответа
- **Fallback**: Последовательное переключение при ошибках
- **Consensus**: Голосование нескольких моделей
- **Iterative**: Итеративное улучшение ответов

##### IntelligentEvaluator (Интеллектуальный оценщик)
**Многофакторная оценка качества ответов:**
- Оценка по 9 аспектам качества (точность, полнота, релевантность, ясность, структура, креативность, техническая точность, безопасность, эффективность)
- Учет контекста и типа задач при оценке
- Детектирование специфических проблем (галлюцинации, неполнота, ошибки форматирования)
- Адаптивная оценка с обучением на обратной связи
- Гибридные методы: rule-based + LLM-based оценка

**Методы оценки:**
- **Rule-based**: Оценка по предопределенным правилам и паттернам
- **LLM-based**: Оценка через специализированные модели
- **Hybrid**: Комбинированная оценка для максимальной точности
- **Comparative**: Сравнение нескольких ответов
- **Reference-based**: Сравнение с эталонными ответами

##### ErrorLearningSystem (Система обучения на ошибках)
**Автоматическое улучшение через анализ ошибок:**
- Анализ неудачных запросов и выявление паттернов ошибок
- Классификация ошибок (API, таймаут, низкое качество, галлюцинации и др.)
- Автоматическая адаптация стратегий для предотвращения повторений
- Генерация инсайтов и рекомендаций по улучшению
- Обучение на исторических данных для proactive предотвращения

**Типы анализируемых ошибок:**
- API ошибки и таймауты
- Нарушения политики контента
- Низкое качество и галлюцинации
- Неполные или нерелевантные ответы
- Ошибки форматирования и сети

**Паттерны ошибок:**
- Перегрузка моделей
- Слишком длинный контекст
- Сложные запросы
- Чувствительный контент
- Неоднозначные запросы

**Поток данных в модульной архитектуре:**

```mermaid
graph TD
    A[LLMManager] --> B{Тип запроса}
    B -->|Одиночный| C[StrategyManager._generate_single]
    B -->|Параллельный| D[StrategyManager._generate_parallel]

    C --> E[ModelRegistry.get_fastest_model]
    E --> F[ClientManager.call_model]
    F --> G{Успех?}
    G -->|Да| H[JsonValidator.validate]
    G -->|Нет| I[Fallback цепочка]

    D --> J[asyncio.gather]
    J --> K[Две модели параллельно]
    K --> L[ResponseEvaluator.compare]
    L --> M[Выбор лучшего ответа]

    H --> N[ModelRegistry.update_stats]
    M --> N
    I --> N
    N --> O[Возврат ответа]
```

**Преимущества модульной архитектуры:**
- **Тестируемость**: Каждый компонент тестируется изолированно
- **Расширяемость**: Легкое добавление новых провайдеров и стратегий
- **Надежность**: Многоуровневая обработка ошибок и fallback стратегии
- **Производительность**: Оптимизация через параллельное выполнение и интеллектуальную маршрутизацию
- **Поддерживаемость**: Четкое разделение ответственностей
- **Интеллектуальность**: Адаптивное поведение и обучение на данных
- **Качество**: Автоматическая оценка и улучшение ответов
- **Устойчивость**: Proactive предотвращение ошибок через анализ паттернов

#### 1.4 Конфигурационный менеджер (`src/core/configuration_manager.py`)

Управление конфигурацией системы с поддержкой:
- Валидации конфигурации
- Горячей перезагрузки настроек
- Типизированного доступа к параметрам

#### 1.5 HTTP сервер (`src/core/http_server.py`)

REST API сервер для:
- Мониторинга состояния агента
- Управления задачами
- Получения метрик производительности

#### 1.6 Сборщик метрик (`src/core/metrics_collector.py`)

Система телеметрии с поддержкой:
- Метрик производительности
- Счетчиков задач
- Времени выполнения операций

#### 1.7 Обработчик ошибок (`src/core/error_handler.py`)

Типизированная система обработки ошибок:
- Классификация ошибок
- Стратегии восстановления
- Логирование исключений

#### 1.8 Наблюдатель файлов (`src/core/file_watcher.py`)

Система отслеживания изменений файлов:
- Мониторинг директорий проекта
- Автоматический перезапуск при изменениях
- Фильтрация событий по типам файлов

#### 1.9 Типы данных (`src/core/types.py`)

Общие типы данных системы:
- **TaskType enum** - Типизация задач проекта (code, docs, refactor, test, release, devops)
- Перечисления состояний выполнения
- Типы конфигураций компонентов
- Структуры данных метрик

**Система типов задач:**
```python
class TaskType(Enum):
    CODE = "code"        # Разработка кода
    DOCS = "docs"        # Документация
    REFACTOR = "refactor"  # Рефакторинг
    TEST = "test"        # Тестирование
    RELEASE = "release"  # Релиз
    DEVOPS = "devops"    # DevOps/инфраструктура
```

**Автоматическое определение типов:**
- Анализ ключевых слов в тексте задач
- Приоритетная обработка (DevOps → Test → Release → Refactor → Docs → Code)
- Ручное переопределение типов при необходимости

### 2. Сервер агента (`src/server.py`)

**Управляющий компонент системы с расширенной конфигурацией:**

CodeAgentServer теперь поддерживает гибкую конфигурацию через параметры инициализации, позволяя переопределять настройки без изменения конфигурационных файлов.

**Новая конструкция с расширенными параметрами:**

```python
class CodeAgentServer:
    def __init__(
        self,
        config_path: Optional[str] = None,
        project_dir: Optional[str] = None,
        docs_dir: Optional[str] = None,
        status_file: Optional[str] = None,
        agent_config: Optional[Dict[str, Any]] = None,
        server_config: Optional[Dict[str, Any]] = None,
        llm_config: Optional[Dict[str, Any]] = None,
        override_config: Optional[Dict[str, Any]] = None
    ):
        # Гибкая инициализация с переопределением настроек
```

**Параметры инициализации:**

| Параметр | Тип | Описание |
|-----------|-----|----------|
| `config_path` | `str` | Путь к основному конфигурационному файлу |
| `project_dir` | `str` | Директория целевого проекта (переопределяет конфиг) |
| `docs_dir` | `str` | Директория документации (переопределяет конфиг) |
| `status_file` | `str` | Файл статуса проекта (переопределяет конфиг) |
| `agent_config` | `Dict` | Конфигурация агента (сливается с основной) |
| `server_config` | `Dict` | Конфигурация сервера (сливается с основной) |
| `llm_config` | `Dict` | Конфигурация LLM модуля (сливается с основной) |
| `override_config` | `Dict` | Полное переопределение всей конфигурации |

**Примеры использования:**

```python
# Базовое использование (как раньше)
server = CodeAgentServer()

# С кастомной директорией проекта
server = CodeAgentServer(project_dir="/path/to/my/project")

# С полной перезагрузкой конфигурации
custom_config = {
    "project_dir": "/custom/project",
    "docs_dir": "/custom/docs",
    "llm": {
        "models": {
            "primary": [{"name": "custom-model", "provider": "custom"}]
        }
    }
}
server = CodeAgentServer(override_config=custom_config)

# Частичное переопределение секций
server = CodeAgentServer(
    agent_config={"verbose": True, "max_iterations": 50},
    llm_config={"strategy": "parallel_quality"}
)
```

**Ответственности:**
- Инициализация и запуск ServerCore
- Управление жизненным циклом сервера
- **Новая:** Гибкая конфигурация через параметры
- **Новая:** Слияние конфигураций с приоритетами
- HTTP API интерфейс
- Интеграция с внешними системами (Git, Docker)
- Обработка сигналов остановки и перезапуска

**Основные функции:**
- `start()` - Запуск сервера с инициализацией ServerCore
- `run_iteration()` - Делегирование выполнения ServerCore
- `_create_server_core()` - Создание экземпляра ServerCore с зависимостями
- **Новая:** `_merge_config_with_overrides()` - Слияние конфигураций
- Автоматическая интеграция с git_utils для push после коммитов

### 2. Менеджер статусов (`src/status_manager.py`)

Управляет файлом статусов проекта `codeAgentProjectStatus.md`:

- Чтение текущего статуса
- Запись новых статусов
- Обновление существующих записей
- Форматирование статусов в Markdown

**Основные методы:**
- `read_status()` - Чтение текущего статуса
- `write_status()` - Запись нового статуса
- `append_status()` - Добавление статуса в конец файла
- `update_task_status()` - Обновление статуса конкретной задачи

### 3. Менеджер задач (`src/todo_manager.py`)

Читает и управляет todo-листом проекта:

- Парсинг различных форматов todo (txt, yaml, md)
- Извлечение иерархии задач
- Отслеживание выполненных задач
- Подготовка задач для агентов

**Основные методы:**
- `load_todos()` - Загрузка todo из файла
- `get_pending_tasks()` - Получение непройденных задач
- `mark_task_done()` - Отметка задачи как выполненной
- `get_task_hierarchy()` - Получение иерархии задач

### 4. Агенты CrewAI (`src/agents/`)

Система поддерживает два типа агентов: базовый **Project Executor Agent** и продвинутый **Smart Agent** с инструментами обучения и анализа контекста.

#### 4.1 Базовый агент исполнителя (`executor_agent.py`)

**Основной агент исполнителя:**
- Роль: "Project Executor Agent"
- Цель: Выполнение задач проекта
- Инструменты: CodeInterpreterTool, чтение файлов, запись файлов

**Важно: Ограничения LLM агента Code Agent**

LLM агента Code Agent - это **слабая языковая модель** на базе бесплатных моделей от доступных провайдеров (например, GPT-3.5-turbo, Claude Haiku, локальные модели через Ollama).

**Ограничения и принципы работы:**

- ⚠️ **Нет Deep Thinking**: LLM агента **никогда не делает глубокий анализ или сложные рассуждения**
- ✅ **Только инструкции**: Работает **строго по предопределенным инструкциям** из конфигурации
- ✅ **Простые действия**: Выполняет только **простые осмысленные действия** для понимания контекста задачи
- ✅ **Минимальный контекст**: Анализирует **только текст задачи** из todo-листа, без анализа документации
- ✅ **Генерация инструкций**: Генерирует **простые инструкции/команды** для Cursor, не код

**Примеры допустимых действий LLM:**
- Парсинг текста задачи из todo-листа
- Определение типа задачи (по ключевым словам)
- Выбор шаблона инструкции из конфигурации
- Подстановка значений в шаблон инструкции
- Простая проверка результатов (наличие файла, контрольная фраза)

**Что LLM НЕ делает:**
- ❌ Глубокий анализ архитектуры проекта
- ❌ Сложное планирование выполнения
- ❌ Генерация кода
- ❌ Анализ документации проекта
- ❌ Принятие сложных решений без инструкций

#### 4.2 Smart Agent (`smart_agent.py`)

**Продвинутый агент с инструментами обучения и анализа:**

**Характеристики:**
- Роль: "Smart Project Executor Agent"
- Цель: Выполнение задач с использованием обучения на предыдущих выполнениях и анализа контекста проекта
- **Backstory**: Агент, который учится на задачах, анализирует проект и использует оптимизированные LLM настройки

**Инструменты Smart Agent:**
- **LearningTool**: Обучение на предыдущих выполнениях задач
- **ContextAnalyzerTool**: Анализ структуры и зависимостей проекта
- **CodeInterpreterTool**: Выполнение кода (опционально, с Docker)
- **Unicode нормализация**: Улучшенный поиск и анализ текста

**Оптимизированные параметры производительности:**
- `max_iter=25` - Увеличено для сложных задач (было 15)
- `memory=100` - Расширена память для длинных сессий (было 50)
- `max_experience_tasks=200` - Больше задач в истории обучения (было 100)
- `verbose=true` - Оптимизировано для production (можно отключать)

**Режимы работы Smart Agent:**

1. **Полный режим (с Docker + LLM)**:
   - Docker контейнеры для безопасного выполнения кода
   - LLM интеграция с best_of_two стратегией
   - Максимальная функциональность

2. **Fallback режим (без Docker)**:
   - Автоматическое переключение при недоступности Docker
   - Работа только с инструментами обучения и анализа
   - Полная функциональность для анализа кода

3. **Tool-only режим**:
   - При отсутствии API ключей для LLM
   - Graceful degradation без потери функциональности

**LLM стратегия best_of_two:**
- Параллельная оценка несколькими моделями
- Критерии качества: relevance, completeness, efficiency
- Автоматический fallback при ошибках
- Поддержка ролей моделей (primary, duplicate, reserve, fallback)

**Специализированные агенты** (для будущего расширения):
- Агент документации
- Агент тестирования
- Агент рефакторинга

### 5. Конфигурация (`config/`)

Файлы конфигурации в формате YAML:

- `config.yaml` - Основные настройки агента
- `agents.yaml` - Определения агентов (опционально)

## Поток данных

### Диаграмма потока данных

```mermaid
graph TD
    A[CodeAgentServer] -->|Загружает конфигурацию| B[ConfigLoader]
    A -->|Читает задачи| C[TodoManager]
    A -->|Обновляет статусы| D[StatusManager]
    A -->|Выполняет задачи| E[CrewAI Agent]
    
    C -->|Читает из| F[PROJECT_DIR/todo.md]
    D -->|Записывает в| G[PROJECT_DIR/codeAgentProjectStatus.md]
    E -->|Читает документацию| H[PROJECT_DIR/docs/]
    E -->|Генерирует инструкции| I[Cursor Interface]
    
    I -->|Отправляет инструкции| J[Cursor IDE]
    J -->|Выполняет работу| K[Код/Тесты/Документация]
    J -->|Создает отчеты| L[PROJECT_DIR/docs/results/]
    
    I -->|Читает результаты| L
    I -->|Возвращает результаты| E
    E -->|Обновляет статус| D
    
    style A fill:#e1f5ff
    style E fill:#fff4e1
    style I fill:#e8f5e9
    style J fill:#f3e5f5
```

### Текстовая диаграмма (альтернатива)

```
┌─────────────────┐
│   Server.py     │  Запуск и управление циклом
└────────┬────────┘
         │
         ├─────────────────┬─────────────────┐
         │                 │                 │
         ▼                 ▼                 ▼
┌─────────────────┐ ┌──────────────┐ ┌──────────────┐
│ TodoManager     │ │StatusManager │ │ CrewAI Agent │
│ - Чтение todo   │ │ - Запись     │ │ - Выполнение │
│ - Парсинг задач │ │   статусов   │ │   задач      │
└────────┬────────┘ └──────────────┘ └──────┬───────┘
         │                                    │
         └────────────────┬───────────────────┘
                          │
                          ▼
                  ┌───────────────┐
                  │   Проект      │
                  │ - docs/       │
                  │ - todo.md     │
                  │ - status.md   │
                  └───────────────┘
```

## Рабочий цикл

### Диаграмма последовательности выполнения задачи

```mermaid
sequenceDiagram
    participant Server as CodeAgentServer
    participant Todo as TodoManager
    participant Agent as CrewAI Agent
    participant Cursor as Cursor Interface
    participant IDE as Cursor IDE
    participant Status as StatusManager
    
    Server->>Todo: Загрузить todo-лист
    Todo-->>Server: Список задач
    
    loop Для каждой задачи
        Server->>Status: Обновить статус (В процессе)
        Server->>Agent: Создать задачу для агента
        Agent->>Agent: Анализ задачи (простой)
        Agent->>Agent: Выбор шаблона инструкции
        Agent->>Cursor: Сгенерировать инструкцию
        Cursor->>IDE: Отправить инструкцию
        IDE->>IDE: Выполнить работу (код/тесты)
        IDE->>IDE: Создать отчет
        Cursor->>Cursor: Прочитать результат
        Cursor-->>Agent: Вернуть результат
        Agent->>Agent: Проверить результат (простая проверка)
        Agent-->>Server: Задача выполнена
        Server->>Status: Обновить статус (Выполнено)
        Server->>Todo: Отметить задачу как выполненную
    end
    
    Server->>Server: Ожидание (check_interval)
```

### Описание цикла

1. **Инициализация**
   - Загрузка конфигурации
   - Инициализация менеджеров (todo, status)
   - Создание агентов CrewAI

2. **Основной цикл** (бесконечный):
   ```
   WHILE True:
       - Загрузить todo-лист
       - Получить непройденные задачи
       - FOR каждой задачи:
           - Создать сессию агента
           - Выполнить задачу через CrewAI
           - Обновить статус
           - Отметить задачу как выполненную
       - Ожидание интервала (check_interval)
   ```

3. **Выполнение задачи**:
   - Code Agent получает описание задачи из todo
   - Code Agent проверяет наличие документации (без чтения содержимого)
   - **LLM (слабая модель) анализирует только текст задачи** - выполняет простые действия:
     * Парсинг текста задачи
     * Определение типа задачи по ключевым словам
     * Выбор шаблона инструкции из конфигурации (без deep thinking)
   - **LLM генерирует инструкции/команды для Cursor** - используя предопределенные шаблоны из конфигурации
   - Code Agent отправляет инструкции агентам Cursor через интерфейс
   - Cursor Agents выполняют работу (код, тесты, документация, deep thinking)
   - Code Agent получает результаты из файлов-репортов
   - **LLM проверяет результаты** - простые проверки (наличие файла, контрольная фраза)
   - Результат записывается в status manager
   - Todo manager обновляет статус задачи

## Расположение файлов

### В директории проекта агента (`codeAgent/`):
- Конфигурация агента
- Исходный код агента
- Документация агента

### В директории обрабатываемого проекта (`PROJECT_DIR/`):
- `docs/` - Документация проекта
- `todo.md` - Список задач (формат по умолчанию, также поддерживаются todo.txt, todo.yaml)
- `codeAgentProjectStatus.md` - Статусы выполнения (создается/обновляется агентом)

## Интеграция с Cursor

Code Agent работает как **координатор задач**, взаимодействуя с Cursor IDE через интерфейс пользователя.

### Диаграмма взаимодействия компонентов

```mermaid
graph LR
    subgraph "Code Agent"
        A[CodeAgentServer]
        B[TodoManager]
        C[StatusManager]
        D[CrewAI Agent]
        E[CursorCLIInterface]
        F[CursorFileInterface]
    end
    
    subgraph "Конфигурация"
        G[config.yaml]
        H[.env]
    end
    
    subgraph "Целевой проект"
        I[todo.md]
        J[docs/]
        K[codeAgentProjectStatus.md]
        L[results/]
    end
    
    subgraph "Cursor IDE"
        M[Cursor Agents]
        N[Выполнение кода]
    end
    
    A -->|Читает| G
    A -->|Использует| H
    A -->|Управляет| B
    A -->|Управляет| C
    A -->|Использует| D
    
    B -->|Читает| I
    C -->|Записывает| K
    
    D -->|Генерирует инструкции| E
    D -->|Fallback| F
    
    E -->|CLI команды| M
    F -->|Файлы инструкций| M
    
    M -->|Выполняет| N
    M -->|Создает отчеты| L
    
    E -->|Читает результаты| L
    F -->|Читает результаты| L
    
    style A fill:#e1f5ff
    style D fill:#fff4e1
    style E fill:#e8f5e9
    style M fill:#f3e5f5
```

### Роли компонентов

- **Code Agent (CrewAI)**: 
  - Читает задачи из todo-листа
  - Планирует выполнение в рамках todo-листа
  - Генерирует команды/инструкции для Cursor (не код!)
  - Контролирует выполнение через файлы-репорты
  - Ведет протокол в `codeAgentProjectStatus.md`

- **Cursor Agents** (очень умные модели последнего поколения):
  - Используют **мощные языковые модели** (GPT-4, Claude Opus, GPT-4 Turbo)
  - **Понимают контекст с полуслова** - не требуют детальных инструкций
  - Получают инструкции от Code Agent
  - Выполняют код и архитектурные задачи (deep thinking)
  - Анализируют документацию проекта (глубокий анализ)
  - Создают планы выполнения
  - **Подробно протоколируют работу** - создают детальные отчеты с полным контекстом
  - Генерируют отчеты о выполнении для Code Agent через файлы-репорты

### Диаграмма последовательности взаимодействия

```mermaid
sequenceDiagram
    participant Todo as TodoManager
    participant Server as CodeAgentServer
    participant LLM as LLM (слабая модель)
    participant Cursor as Cursor Agents
    participant Files as Файловая система
    
    Todo->>Server: Задача из todo.md
    Server->>Server: Проверка docs/ (только наличие)
    Server->>LLM: Анализ задачи
    Note over LLM: Парсинг текста<br/>Определение типа<br/>Выбор шаблона
    LLM->>Server: Инструкция (из шаблона)
    Server->>Cursor: Отправка инструкции
    Note over Cursor: Deep thinking<br/>Генерация кода<br/>Анализ документации
    Cursor->>Files: Создание/изменение файлов
    Cursor->>Files: Запись результата
    Files->>Server: Чтение результата
    Server->>LLM: Проверка результата
    Note over LLM: Простая проверка<br/>(файл, фраза)
    LLM->>Server: Результат проверки
    Server->>Status: Обновление статуса
    Server->>Todo: Отметка задачи
```

### Процесс взаимодействия

1. **Code Agent читает задачу** из todo.md
2. **Code Agent проверяет документацию** - только наличие файлов в docs/, не читает содержимое
3. **LLM (слабая модель) анализирует задачу** - простые действия:
   - Парсинг текста задачи из todo-листа
   - Определение типа задачи по ключевым словам
   - Выбор шаблона инструкции из конфигурации (без deep thinking)
4. **LLM генерирует инструкции** - используя предопределенные шаблоны, не создает новые планы
5. **Cursor выполняет работу** - код, тесты, документация, архитектурное планирование выполняются агентами Cursor
6. **Code Agent получает результаты** - текстовые репорты из файлов
7. **LLM проверяет результаты** - простые проверки (наличие файла, контрольная фраза)
8. **Code Agent обновляет статус** - в `codeAgentProjectStatus.md`

**Важно:** LLM Code Agent работает **строго по инструкциям** из конфигурации и не делает глубокий анализ или сложные рассуждения. Вся интеллектуальная работа выполняется агентами Cursor.

Подробнее см. [Интеграция с Cursor](../integration/cursor_integration.md), [Детальный рабочий процесс](workflow_detailed.md) и [Система верификации](verification_system.md)

## Git интеграция

### Автоматический push после коммитов

Система включает интеграцию с Git для автоматической отправки коммитов в удаленный репозиторий:

- **Триггер:** После успешного выполнения инструкции 8 (Коммит и отправка)
- **Проверки:**
  - Существование последнего коммита
  - Разрешение текущей ветки для авто-push
  - Наличие неотправленных коммитов
- **Действия:** Выполнение `git push origin <branch>` с таймаутом
- **Логирование:** Подробная информация о каждом шаге

### Контроль разрешений веток

Для обеспечения безопасности реализован контроль разрешений веток:

- **По умолчанию:** Только ветка `smart` разрешена для авто-push
- **Настройка:** Список разрешенных веток в `config/config.yaml`
- **Безопасность:** Предотвращает автоматические push в основные ветки (`main`, `master`)

### Компоненты Git интеграции

- **`src/git_utils.py`** - Утилиты для работы с Git командами
- **`src/server.py`** - Интеграция автоматического push в основной цикл
- **Конфигурация** - Настройки в `config/config.yaml` (секция `smart_git`)

## SOLID принципы и Dependency Injection

### Реализация SOLID принципов

**1. Single Responsibility Principle (SRP)**
- Каждый компонент отвечает только за одну задачу
- ServerCore управляет только циклом выполнения
- TodoManager только управляет задачами
- StatusManager только управляет статусами

**2. Open/Closed Principle (OCP)**
- Компоненты открыты для расширения через интерфейсы
- Новые реализации менеджеров могут быть добавлены без изменения существующего кода
- DI контейнер позволяет легко заменять реализации

**3. Liskov Substitution Principle (LSP)**
- Все реализации интерфейсов могут быть заменены друг на друга
- ServerCore работает с любыми реализациями ITodoManager, IStatusManager и т.д.

**4. Interface Segregation Principle (ISP)**
- Интерфейсы разделены по ответственности
- IManager содержит только общие методы
- Специализированные интерфейсы (ITodoManager, IStatusManager) содержат только нужные методы

**5. Dependency Inversion Principle (DIP)**
- Высокоуровневые модули не зависят от низкоуровневых
- Все зависимости инжектируются через конструкторы
- Используются абстракции (интерфейсы), а не конкретные реализации

### Dependency Injection контейнер

**Возможности:**
- Регистрация сервисов с различными жизненными циклами
- Автоматическое разрешение зависимостей
- Поддержка фабричных функций
- Обнаружение циклических зависимостей
- Управление жизненным циклом компонентов

**Преимущества:**
- Слабая связанность компонентов
- Легкое тестирование с mock объектами
- Гибкая конфигурация системы
- Возможность замены реализаций без изменения кода

### Тестирование

**Модульные тесты (`test/test_di_solid.py`):**
- Тесты DI контейнера и его функциональности
- Тесты интерфейсных контрактов
- Тесты SOLID принципов
- Интеграционные тесты взаимодействия компонентов

**Принципы тестирования:**
- Все компоненты тестируются изолированно через интерфейсы
- Используются mock объекты для зависимостей
- Тесты проверяют контракты интерфейсов
- Интеграционные тесты проверяют совместную работу

## Расширяемость

Архитектура позволяет легко добавлять:

- Новые типы агентов для специализированных задач
- Дополнительные форматы todo-листов
- Интеграции с другими инструментами
- Веб-интерфейс для мониторинга
- API для внешнего управления
- Новые реализации интерфейсов без изменения существующего кода

## Smart Agent архитектура

### Компоненты Smart Agent

#### LearningTool
**Инструмент обучения на опыте:**
- Хранит историю выполнения задач в `smart_experience/`
- Анализирует успешные паттерны решения задач
- Предоставляет рекомендации на основе предыдущего опыта
- Максимальное количество задач: `max_experience_tasks=200`

**Структура опыта:**
```json
{
  "task_type": "documentation_update",
  "success_patterns": ["check_dependencies", "update_links", "validate_structure"],
  "common_issues": ["broken_links", "outdated_examples"],
  "recommendations": ["use_check_doc_links_script", "validate_examples"]
}
```

#### ContextAnalyzerTool
**Инструмент анализа контекста проекта:**
- Анализирует структуру проекта и зависимости
- Unicode нормализация для улучшенного поиска
- Case-insensitive поиск с поддержкой различных языков
- Поиск связей между компонентами проекта

**Функции анализа:**
- `normalize_unicode_text()` - Unicode нормализация текста
- `find_related_files()` - Поиск связанных файлов
- `analyze_dependencies()` - Анализ зависимостей
- `suggest_improvements()` - Рекомендации по улучшению

#### Docker интеграция
**Безопасное выполнение кода:**
- Автоматическое определение доступности Docker
- Fallback режим при недоступности Docker
- CodeInterpreterTool в изолированных контейнерах
- Docker utils: DockerChecker, DockerManager

#### LLM интеграция
**Многоуровневая система LLM:**
- **OpenRouter**: Продвинутые модели (Claude-3.5, GPT-4o, WizardLM)
- **LLMManager**: Автоматический выбор с best_of_two стратегией
- **Graceful degradation**: Tool-only режим при отсутствии API ключей

**Best_of_two стратегия:**
- Параллельная оценка задачами
- Критерии: quality, relevance, completeness, efficiency
- Автоматический выбор лучшей модели
- Fallback цепочка при ошибках

**Детальное описание best_of_two стратегии:** См. [docs/integration/best_of_two_strategy.md](../integration/best_of_two_strategy.md)

### Диаграмма Smart Agent

```mermaid
graph TD
    A[Smart Agent] --> B{Доступен Docker?}
    A --> C{Доступны LLM API?}

    B -->|Да| D[CodeInterpreterTool]
    B -->|Нет| E[Fallback: LearningTool + ContextAnalyzerTool]

    C -->|Да| F[LLMManager с best_of_two]
    C -->|Нет| G[Tool-only режим]

    D --> H[Полный режим]
    E --> H
    F --> H
    G --> H

    H --> I[Оптимизированные параметры]
    I --> J[max_iter=25, memory=100, experience=200]

    style A fill:#e1f5ff
    style H fill:#fff4e1
    style I fill:#e8f5e9
```

### Производительность и оптимизация

**Параметры производительности Smart Agent:**

| Параметр | Значение | Эффект |
|----------|----------|--------|
| `max_iter` | 25 | Лучше справляется со сложными задачами |
| `memory` | 100 | Увеличивает контекст для длинных сессий |
| `max_experience_tasks` | 200 | Больше опыта для обучения |
| `verbose` | Оптимизирован | Можно отключать в production |

**Подробный анализ оптимизации:** См. [docs/planning/parameter_optimization_analysis.md](../planning/parameter_optimization_analysis.md)

**Оптимизация verbose режима:**
- Подробное логирование для отладки
- Возможность отключения в production средах
- Автоматическая настройка в зависимости от окружения

### Режимы работы и fallback

#### 1. Полный режим (рекомендуемый)
- Docker + LLM + все инструменты
- Максимальная функциональность и безопасность
- Автоматическое определение доступности компонентов

#### 2. Docker-only режим
- Docker без LLM (при отсутствии API ключей)
- CodeInterpreterTool + LearningTool + ContextAnalyzerTool
- Безопасное выполнение кода без внешних зависимостей

#### 3. LLM-only режим
- LLM без Docker (при недоступности Docker)
- LearningTool + ContextAnalyzerTool + LLM интеграция
- Аналитическая мощность без code execution

#### 4. Tool-only режим (graceful degradation)
- Только инструменты обучения и анализа
- Максимальная стабильность и минимальные зависимости
- Полная функциональность для анализа и рекомендаций

**Подробности миграции и настройки:** См. [docs/guides/migration_guide.md](../guides/migration_guide.md)

### Безопасность Smart Agent

**Уровни безопасности:**
- **Docker изоляция**: Код выполняется в контейнерах
- **API ключи**: Защищенное хранение и использование
- **Файловые разрешения**: Строгие ограничения на чтение/запись
- **Fallback механизмы**: Продолжение работы при сбоях компонентов

**Контроль разрешений:**
- Ограничение команд Shell через whitelist/blacklist
- Паттерны для безопасного доступа к файлам
- Автоматическая валидация путей и команд

## Безопасность

- `allow_code_execution=True` используется с осторожностью
- CodeInterpreterTool должен работать в изолированной среде (Docker/песочница)
- Чтение/запись файлов ограничено директорией проекта
- Smart Agent добавляет дополнительные уровни безопасности через Docker и LLM fallback
