# Задача #3: Асинхронная архитектура и concurrency

## Обзор задачи

**Название:** Асинхронная архитектура и concurrency

**Описание:** Перевести core loop на asyncio с uvloop оптимизациями, реализовать асинхронный файловый I/O с aiofiles, оптимизировать LLM requests с connection multiplexing, добавить HTTP/2 support для external APIs и внедрить coroutine-based task scheduling.

**Приоритет:** Высокий

**Сложность:** Высокая

## Техническое описание

### Текущая архитектура (синхронная)

Code Agent работает на полностью синхронной архитектуре:

1. **Основной цикл сервера** - синхронный `while True` с `time.sleep(check_interval)`
2. **Блокирующий I/O** - чтение/запись файлов через стандартные методы Python
3. **LLM запросы** - выполняются через `asyncio.run()` в блокирующем контексте
4. **Синхронизация** - threading.Lock для защиты ресурсов
5. **Выполнение задач** - последовательное, блокирующее выполнение через Cursor CLI

### Целевая архитектура (асинхронная)

Переход к полностью асинхронной event-driven архитектуре:

1. **Event Loop** - asyncio с uvloop оптимизациями
2. **Асинхронный I/O** - aiofiles для файловых операций
3. **HTTP клиент** - aiohttp с HTTP/2 и connection pooling
4. **Task Scheduling** - coroutine-based планировщик задач
5. **Concurrency Patterns** - async/await паттерны, concurrent.futures для CPU-bound задач

## Архитектурные решения

### 1. Event Loop Architecture

```python
# Основной event loop с uvloop оптимизациями
import asyncio
import uvloop

class AsyncCodeAgentServer:
    def __init__(self):
        self.loop = None
        self.tasks = []
        self.running = False

    async def start(self):
        """Асинхронный запуск сервера"""
        asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
        self.loop = asyncio.get_event_loop()

        # Запуск фоновых задач
        self.tasks = [
            self._task_scheduler(),
            self._file_watcher(),
            self._health_monitor()
        ]

        await asyncio.gather(*self.tasks)

    async def _task_scheduler(self):
        """Coroutine-based task scheduler"""
        while self.running:
            await self._process_pending_tasks()
            await asyncio.sleep(self.check_interval)
```

### 2. Асинхронный I/O Layer

```python
import aiofiles
import aiohttp

class AsyncIOManager:
    def __init__(self):
        self.session = None
        self.connector = None

    async def init_session(self):
        """Инициализация HTTP сессии с connection pooling"""
        self.connector = aiohttp.TCPConnector(
            limit=100,  # Connection pool
            limit_per_host=10,
            ttl_dns_cache=30,
            use_dns_cache=True
        )

        self.session = aiohttp.ClientSession(
            connector=self.connector,
            timeout=aiohttp.ClientTimeout(total=30),
            version=aiohttp.HttpVersion11  # HTTP/2 support
        )

    async def read_file_async(self, path: Path) -> str:
        """Асинхронное чтение файла"""
        async with aiofiles.open(path, 'r', encoding='utf-8') as f:
            return await f.read()

    async def write_file_async(self, path: Path, content: str):
        """Асинхронная запись файла"""
        async with aiofiles.open(path, 'w', encoding='utf-8') as f:
            await f.write(content)

    async def llm_request_async(self, prompt: str) -> str:
        """Асинхронный LLM запрос с connection multiplexing"""
        async with self.session.post(
            self.llm_endpoint,
            json={"prompt": prompt},
            headers=self.headers
        ) as response:
            return await response.json()
```

### 3. Coroutine-based Task Execution

```python
class AsyncTaskExecutor:
    def __init__(self):
        self.semaphore = asyncio.Semaphore(5)  # Ограничение concurrency
        self.task_queue = asyncio.Queue()

    async def execute_task_async(self, task: TodoItem) -> bool:
        """Асинхронное выполнение задачи"""
        async with self.semaphore:
            # Параллельная подготовка
            doc_reading, llm_analysis = await asyncio.gather(
                self._read_documentation_async(task),
                self._analyze_task_async(task)
            )

            # Последовательное выполнение через Cursor
            await self._execute_via_cursor_async(task, doc_reading, llm_analysis)

            return True

    async def _execute_via_cursor_async(self, task, docs, analysis):
        """Асинхронное выполнение через Cursor с таймаутами"""
        instructions = self._generate_instructions(task, docs, analysis)

        for instruction in instructions:
            try:
                await asyncio.wait_for(
                    self._send_cursor_instruction_async(instruction),
                    timeout=instruction.timeout
                )

                # Ожидание результата с polling
                await self._wait_for_result_async(instruction.wait_file)

            except asyncio.TimeoutError:
                await self._handle_timeout_async(instruction)
```

### 4. Graceful Shutdown и Lifecycle Management

```python
class AsyncLifecycleManager:
    def __init__(self):
        self.shutdown_event = asyncio.Event()
        self.tasks = set()

    async def graceful_shutdown(self):
        """Graceful shutdown всех компонентов"""
        logger.info("Инициирован graceful shutdown")

        # Сигнал всем задачам о завершении
        self.shutdown_event.set()

        # Ожидание завершения всех задач с таймаутом
        done, pending = await asyncio.wait(
            self.tasks,
            timeout=30,
            return_when=asyncio.ALL_COMPLETED
        )

        # Принудительное завершение зависших задач
        for task in pending:
            task.cancel()

        # Закрытие ресурсов
        await self._cleanup_resources()

    async def create_task(self, coro):
        """Создание отслеживаемой задачи"""
        task = asyncio.create_task(coro)
        self.tasks.add(task)
        task.add_done_callback(self.tasks.discard)
        return task
```

## План реализации

### Этап 1: Инфраструктура (1 неделя)
1. **Создание async базовых классов**
   - `AsyncServerCore` - базовый класс сервера
   - `AsyncIOManager` - менеджер асинхронного I/O
   - `AsyncTaskScheduler` - планировщик задач

2. **Миграция конфигурации**
   - Добавление async настроек в `config.yaml`
   - Конфигурация connection pooling
   - Настройки uvloop и asyncio

3. **Создание async утилит**
   - `async_file_utils.py` - асинхронные операции с файлами
   - `async_http_client.py` - HTTP клиент с HTTP/2
   - `async_lock_manager.py` - замена threading.Lock

### Этап 2: Core Loop (2 недели)
1. **Миграция основного цикла**
   - Перевод `start()` на async/await
   - Замена `while True + time.sleep` на `asyncio.sleep`
   - Интеграция uvloop

2. **Асинхронный I/O**
   - Миграция всех файловых операций на aiofiles
   - Асинхронное чтение конфигурации
   - Async логирование

3. **Task Management**
   - Async методы для TodoManager
   - Async StatusManager
   - Async CheckpointManager

### Этап 3: LLM и External APIs (1 неделя)
1. **HTTP/2 клиент**
   - Интеграция aiohttp с HTTP/2
   - Connection multiplexing
   - Automatic retries и circuit breaker

2. **LLM оптимизация**
   - Async LLM requests
   - Connection pooling для API calls
   - Параллельные запросы к разным моделям

3. **External API интеграции**
   - Async Git operations
   - Async Docker API
   - Async monitoring APIs

### Этап 4: Task Execution (2 недели)
1. **Cursor Interface**
   - Async CLI execution
   - Async file monitoring
   - Coroutine-based instruction execution

2. **Task Scheduling**
   - Async task queue
   - Concurrency control (semaphore)
   - Priority-based scheduling

3. **Error Handling**
   - Async exception handling
   - Timeout management
   - Recovery strategies

### Этап 5: Тестирование и оптимизация (1 неделя)
1. **Интеграционное тестирование**
   - Async unit tests
   - Performance benchmarks
   - Memory usage monitoring

2. **Оптимизация**
   - Connection pool tuning
   - Memory management
   - CPU usage optimization

3. **Документация и миграция**
   - Обновление документации
   - Миграционные скрипты
   - Backward compatibility

## Потенциальные риски и митигация

### Риск 1: Сложность отладки
**Описание:** Async код сложнее отлаживать из-за stack trace и race conditions
**Вероятность:** Высокая
**Влияние:** Среднее

**Митигация:**
- Использование `asyncio.debug = True`
- Структурированное логирование с task IDs
- Async context managers для resource tracking
- Unit тесты с async fixtures

### Риск 2: Performance degradation
**Описание:** Неправильная реализация может привести к ухудшению производительности
**Вероятность:** Средняя
**Влияние:** Высокое

**Митигация:**
- Бенчмаркинг на каждом этапе
- Профилирование с `aiohttp-devtools`
- Connection pool monitoring
- Memory leak detection

### Риск 3: Backward compatibility
**Описание:** Изменения могут сломать существующие интеграции
**Вероятность:** Средняя
**Влияние:** Высокое

**Митигация:**
- Интерфейсная совместимость
- Feature flags для постепенной миграции
- Comprehensive integration tests
- Rollback procedures

### Риск 4: Resource leaks
**Описание:** Неправильное управление ресурсами в async коде
**Вероятность:** Высокая
**Влияние:** Высокое

**Митигация:**
- Async context managers для всех ресурсов
- Connection pool monitoring
- Graceful shutdown procedures
- Memory profiling tools

### Риск 5: Race conditions
**Описание:** Concurrent access к shared state
**Вероятность:** Высокая
**Влияние:** Критическое

**Митигация:**
- Async locks (asyncio.Lock)
- Immutable data structures
- Actor pattern для state management
- Comprehensive testing с concurrent scenarios

## Критерии приемки

### Функциональные критерии
- [ ] Сервер запускается и работает в async режиме
- [ ] Все файловые операции работают асинхронно
- [ ] LLM запросы выполняются с connection multiplexing
- [ ] HTTP/2 поддержка для external APIs
- [ ] Task scheduling работает с concurrency control
- [ ] Все существующие функции работают без изменений

### Нефункциональные критерии
- [ ] Производительность не ухудшилась (min 95% от baseline)
- [ ] Memory usage в пределах нормы (±10%)
- [ ] Latency LLM запросов уменьшилась на 20%
- [ ] Concurrent tasks: минимум 10 одновременных задач
- [ ] CPU usage оптимизирован

### Качественные критерии
- [ ] Код прошел code review
- [ ] Unit test coverage > 90%
- [ ] Integration tests проходят
- [ ] Documentation обновлена
- [ ] Backward compatibility сохранена

## Связь с другими задачами

### Зависимости
1. **Задача #1 (Декомпозиция монолитного server.py)** - Блокирующая
   - Текущая задача зависит от декомпозиции
   - Нужен разделенный код для миграции на async

2. **Задача #2 (Dependency injection и SOLID)** - Параллельная
   - Можно реализовывать параллельно
   - Async архитектура хорошо сочетается с DI

### Следующие задачи
1. **Задача #4 (Двусторонняя связь с Cursor)** - Зависит от async
   - WebSocket API требует async foundation
   - Real-time события лучше реализовывать на asyncio

2. **Задача #5 (Контекстная память проекта)** - Параллельная
   - Векторная БД может быть async
   - Лучше реализовывать после core async

3. **Задача #6 (Адаптивный планировщик задач)** - Зависит от async
   - ML inference требует async execution
   - A/B testing лучше на async foundation

### Архитектурная совместимость
- **Совместимо** с задачами 2, 5, 7, 8
- **Улучшает** задачи 4, 6, 9, 10
- **Требуется для** enterprise интеграций (задача 12)

## Тестирование

### Unit Testing
```python
@pytest.mark.asyncio
async def test_async_file_io():
    manager = AsyncIOManager()
    await manager.init_session()

    # Test async file operations
    test_content = "test content"
    test_path = Path("test_file.txt")

    await manager.write_file_async(test_path, test_content)
    content = await manager.read_file_async(test_path)

    assert content == test_content

    # Cleanup
    test_path.unlink()
```

### Integration Testing
```python
@pytest.mark.asyncio
async def test_full_async_workflow():
    server = AsyncCodeAgentServer()
    await server.start()

    # Test concurrent task execution
    tasks = [TodoItem(f"Task {i}") for i in range(10)]
    results = await asyncio.gather(*[
        server.execute_task_async(task) for task in tasks
    ])

    assert all(results)
```

### Performance Testing
- **Latency benchmarks** для LLM запросов
- **Throughput testing** для concurrent tasks
- **Memory profiling** с tracemalloc
- **Connection pool monitoring**

## Миграционная стратегия

### Фазовая миграция
1. **Фаза 1:** Infrastructure (недели 1-2)
   - Создание async компонентов
   - Параллельная работа sync/async

2. **Фаза 2:** Core migration (недели 3-4)
   - Постепенная миграция методов
   - Feature flags для переключения

3. **Фаза 3:** Full async (неделя 5)
   - Полный переход на async
   - Удаление sync кода

### Rollback Plan
- **Quick rollback:** Feature flag отключения async
- **Gradual rollback:** Поэтапное возвращение к sync
- **Data safety:** Checkpoint compatibility

## Метрики успеха

### Quantitative Metrics
- **Response time:** < 100ms для file operations
- **Throughput:** > 50 tasks/hour
- **Memory usage:** < 500MB baseline
- **CPU usage:** < 70% average

### Qualitative Metrics
- **Maintainability:** Код стал легче поддерживать
- **Debuggability:** Легче находить и исправлять ошибки
- **Scalability:** Легче добавлять новые функции
- **Reliability:** Меньше race conditions и deadlocks

---

**Дата создания:** 2026-01-23
**Версия документа:** 1.0
**Автор:** Code Agent
**Статус:** Готово к реализации