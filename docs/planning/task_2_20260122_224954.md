# Задача #2: Внедрение Dependency Injection паттерна

**Идентификатор:** task_2_20260122_224954
**Приоритет:** Критический (Архитектурный рефакторинг ядра)
**Статус:** Планирование
**Дата создания:** 2026-01-23

## Техническое описание задачи

### Проблематика текущей архитектуры

Анализ текущего состояния системы Code Agent показывает следующие проблемы:

1. **Тесная связанность компонентов**: Класс `CodeAgentServer` (4500+ строк) напрямую создает все зависимости в конструкторе
2. **Сложность тестирования**: Отсутствие возможности подмены зависимостей делает модульное тестирование невозможным
3. **Жесткая конфигурация**: Компоненты жестко привязаны к конкретным реализациям
4. **Проблемы с жизненным циклом**: Нет централизованного управления созданием и уничтожением компонентов
5. **Отсутствие интерфейсов**: Компоненты взаимодействуют напрямую, без абстракций

### Цели внедрения Dependency Injection

1. **Разделение ответственности**: Выделить создание зависимостей из бизнес-логики
2. **Улучшение тестируемости**: Возможность подмены зависимостей mock-объектами
3. **Повышение гибкости**: Легкая замена реализаций компонентов
4. **Централизованное управление**: Единая точка конфигурации всех зависимостей
5. **Управление жизненным циклом**: Контроль создания и уничтожения компонентов

## Архитектурные решения и обоснование

### 1. Структура модуля Dependency Injection

```
src/di/
├── __init__.py
├── container.py          # Основной DI контейнер
├── interfaces/           # Интерфейсы сервисов
│   ├── __init__.py
│   ├── iserver.py
│   ├── itask_manager.py
│   ├── istatus_manager.py
│   ├── iconfig_loader.py
│   └── illm_manager.py
├── factories/            # Фабрики компонентов
│   ├── __init__.py
│   ├── agent_factory.py
│   ├── llm_factory.py
│   ├── interface_factory.py
│   └── service_factory.py
├── lifecycle.py          # Управление жизненным циклом
└── exceptions.py         # Исключения DI
```

### 2. Интерфейсная архитектура

#### Основные интерфейсы сервисов:

**IServer** - интерфейс основного сервера
```python
class IServer(ABC):
    @abstractmethod
    async def start(self) -> None:
        """Запуск сервера"""

    @abstractmethod
    async def stop(self) -> None:
        """Остановка сервера"""

    @abstractmethod
    async def process_iteration(self) -> bool:
        """Обработка одной итерации"""
```

**ITaskManager** - интерфейс менеджера задач
```python
class ITaskManager(ABC):
    @abstractmethod
    def load_todos(self) -> List[TodoItem]:
        """Загрузка списка задач"""

    @abstractmethod
    def get_pending_tasks(self) -> List[TodoItem]:
        """Получение невыполненных задач"""

    @abstractmethod
    def mark_task_done(self, task_id: str) -> None:
        """Отметка задачи как выполненной"""
```

**ILLMManager** - интерфейс менеджера LLM
```python
class ILLMManager(ABC):
    @abstractmethod
    async def call_llm(self, prompt: str, **kwargs) -> str:
        """Вызов LLM модели"""

    @abstractmethod
    def get_available_models(self) -> List[str]:
        """Получение списка доступных моделей"""
```

### 3. Контейнер зависимостей

Основной DI контейнер будет реализован как синглтон с lazy loading:

```python
class DependencyContainer:
    def __init__(self):
        self._services: Dict[str, Any] = {}
        self._factories: Dict[str, Callable] = {}
        self._singletons: Dict[str, Any] = {}

    def register_singleton(self, interface: Type[T], implementation: Type[T]) -> None:
        """Регистрация синглтон-сервиса"""

    def register_factory(self, interface: Type[T], factory: Callable[[], T]) -> None:
        """Регистрация фабрики"""

    def resolve(self, interface: Type[T]) -> T:
        """Разрешение зависимости"""
```

### 4. Фабрики компонентов

#### AgentFactory - фабрика агентов
```python
class AgentFactory:
    def __init__(self, container: DependencyContainer):
        self.container = container

    def create_executor_agent(self, config: Dict[str, Any]) -> IAgent:
        """Создание агента-исполнителя"""

    def create_smart_agent(self, config: Dict[str, Any]) -> IAgent:
        """Создание Smart Agent"""
```

#### LLMFactory - фабрика LLM компонентов
```python
class LLMFactory:
    def __init__(self, container: DependencyContainer):
        self.container = container

    def create_llm_manager(self, config: Dict[str, Any]) -> ILLMManager:
        """Создание менеджера LLM"""

    def create_openrouter_client(self, config: Dict[str, Any]) -> IOpenRouterClient:
        """Создание OpenRouter клиента"""
```

### 5. Управление жизненным циклом

Система управления жизненным циклом компонентов:

```python
class LifecycleManager:
    def __init__(self, container: DependencyContainer):
        self.container = container
        self._disposables: List[IDisposable] = []

    async def initialize(self) -> None:
        """Инициализация всех компонентов"""

    async def dispose(self) -> None:
        """Освобождение ресурсов всех компонентов"""

    def register_disposable(self, disposable: IDisposable) -> None:
        """Регистрация компонента для освобождения ресурсов"""
```

## План реализации

### Этап 1: Создание базовой инфраструктуры DI (1-2 дня)

1. **Создание модуля src/di/**
   - Базовая структура директорий
   - Основные интерфейсы (IServer, ITaskManager, etc.)
   - DependencyContainer базовый класс

2. **Интерфейсы основных сервисов**
   - IConfigLoader, IStatusManager, ITodoManager
   - ILLMManager, IAgent, ICursorInterface
   - IDisposable для управления жизненным циклом

3. **Базовый контейнер зависимостей**
   - Регистрация сервисов
   - Разрешение зависимостей
   - Поддержка singleton и transient жизненных циклов

### Этап 2: Фабрики компонентов (2-3 дня)

1. **AgentFactory**
   - create_executor_agent()
   - create_smart_agent()
   - Интеграция с конфигурацией

2. **LLMFactory**
   - create_llm_manager()
   - create_openrouter_client()
   - Поддержка разных провайдеров

3. **ServiceFactory**
   - create_config_loader()
   - create_status_manager()
   - create_todo_manager()

4. **InterfaceFactory**
   - create_cursor_cli_interface()
   - create_cursor_file_interface()

### Этап 3: Рефакторинг CodeAgentServer (3-4 дня)

1. **Внедрение интерфейсов**
   - Обновление конструктора для приема зависимостей
   - Замена прямых созданий на разрешение через DI

2. **Миграция зависимостей**
   - StatusManager → IStatusManager
   - TodoManager → ITodoManager
   - ConfigLoader → IConfigLoader
   - Agent → IAgent

3. **Обновление инициализации**
   - Создание контейнера в main.py
   - Регистрация всех зависимостей
   - Передача контейнера в CodeAgentServer

### Этап 4: Управление жизненным циклом (1-2 дня)

1. **IDisposable интерфейс**
   - Определение контракта для освобождения ресурсов
   - Реализация в компонентах с ресурсами

2. **LifecycleManager**
   - Инициализация компонентов в правильном порядке
   - Освобождение ресурсов при завершении

3. **Интеграция с основным циклом**
   - Обработка сигналов завершения
   - Graceful shutdown всех компонентов

### Этап 5: Тестирование и валидация (2-3 дня)

1. **Модульные тесты**
   - Тесты фабрик
   - Тесты контейнера DI
   - Тесты жизненного цикла

2. **Интеграционные тесты**
   - Тесты взаимодействия компонентов
   - Тесты полного цикла работы

3. **Рефакторинг существующих тестов**
   - Обновление тестов для работы с DI
   - Mock зависимости вместо реальных

## Потенциальные риски и их митигация

### Риск 1: Регрессии в существующей функциональности
**Митигация:**
- Постепенная миграция компонентов
- Полное покрытие тестами перед рефакторингом
- Фallback механизмы для отката изменений

### Риск 2: Снижение производительности
**Митигация:**
- Lazy loading для тяжелых компонентов
- Кэширование singleton сервисов
- Профилирование производительности на каждом этапе

### Риск 3: Увеличение сложности кода
**Митигация:**
- Четкая документация всех интерфейсов
- Простые фабрики без сложной логики
- Code review для поддержания читаемости

### Риск 4: Проблемы с циклическими зависимостями
**Митигация:**
- Анализ зависимостей перед регистрацией
- Использование property injection где возможно
- Рефакторинг архитектуры при обнаружении циклов

## Критерии приемки

### Функциональные критерии
- [ ] CodeAgentServer успешно запускается с DI контейнером
- [ ] Все существующие функции работают без изменений
- [ ] Возможность подмены любого компонента в тестах
- [ ] Graceful shutdown всех компонентов

### Нефункциональные критерии
- [ ] Увеличение покрытия тестами минимум на 20%
- [ ] Отсутствие снижения производительности (>5%)
- [ ] Все интерфейсы документированы
- [ ] Код соответствует принципам SOLID

### Тестовые критерии
- [ ] 100% покрытие нового кода тестами
- [ ] Прохождение всех существующих тестов
- [ ] Успешное создание mock-объектов для всех интерфейсов
- [ ] Интеграционные тесты полного цикла

## Связь с другими задачами и компонентами проекта

### Зависимости от других задач
- **Задача #1**: "Разбить монолитный server.py на модули" - создаст базовые компоненты для DI
- **Задача #3**: "Внедрить Quality Gates систему" - использует DI для внедрения валидаторов
- **Задача #4**: "Усилить верификацию результатов" - интегрируется через DI интерфейсы

### Влияние на компоненты проекта
- **server.py**: Основной рефакторинг, внедрение DI
- **agents/**: Обновление для работы через интерфейсы
- **llm/**: Интеграция с ILLMManager интерфейсом
- **tools/**: Возможность внедрения через DI
- **test/**: Улучшение тестируемости всех компонентов

### Интеграционные точки
- **Конфигурация**: config/config.yaml - настройки DI контейнера
- **Логирование**: Интеграция с существующей системой логирования
- **Мониторинг**: Добавление метрик для DI компонентов
- **Безопасность**: Валидация зависимостей на безопасность

## Оценка трудозатрат

### Разработка: 10-14 дней
- Этап 1: 1-2 дня
- Этап 2: 2-3 дня
- Этап 3: 3-4 дня
- Этап 4: 1-2 дня
- Этап 5: 2-3 дня

### Тестирование: 3-5 дней
- Модульные тесты: 1-2 дня
- Интеграционные тесты: 1-2 дня
- Рефакторинг существующих тестов: 1 день

### Документация: 1-2 дня
- Техническая документация
- Обновление API docs
- Руководства по использованию

**Итого: 14-21 день**

## Следующие шаги

1. **Анализ существующих зависимостей** в CodeAgentServer
2. **Создание прототипа DI контейнера** для проверки концепции
3. **Разработка плана миграции** с учетом обратной совместимости
4. **Создание базовых интерфейсов** и их реализаций

---

**Ответственный:** Команда архитектуры
**Рецензенты:** Команда QA, Tech Lead
**Дата ревью:** После завершения этапа 1